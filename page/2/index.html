<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="小二、上酒" type="application/atom+xml">






<meta name="description" content="人生当苦无妨，良人当归即好">
<meta property="og:type" content="website">
<meta property="og:title" content="小二、上酒">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="小二、上酒">
<meta property="og:description" content="人生当苦无妨，良人当归即好">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小二、上酒">
<meta name="twitter:description" content="人生当苦无妨，良人当归即好">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>小二、上酒</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小二、上酒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/回溯算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/回溯算法/" itemprop="url">回溯算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯算法其实就是常说的 DFS 算法，本质上就是一种暴力穷举算法。</p>
<p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。只需要思考三个问题：</p>
<ol>
<li>路径：也就是已经做出的选择</li>
<li>选择列表：当前可以做的选择</li>
<li>结束条件：到达决策树底层，无法再做选择的条件</li>
</ol>
<p>回溯算法的框架：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径，选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p><strong>其核心就是 for 循环里面的递归，在递归调用之前做选择，在递归调用之后撤销选择。</strong></p>
<h3 id="一、全排列问题"><a href="#一、全排列问题" class="headerlink" title="一、全排列问题"></a>一、全排列问题</h3><p>排列组合问题。n 个不重复的数，全排列共有 <code>n!</code> 个。</p>
<p><strong>PS：为了简单起见，这次讨论的全排列问题不包含重复的数字</strong></p>
<p>比方说给三个数 <code>[1, 2, 3]</code>，如何穷举全排列。</p>
<p><img src="https://labuladong.github.io/algo/images/backtracking/1.jpg" alt="全排列"></p>
<p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。不妨<strong>将这棵树成为回溯算法的 “决策树”</strong></p>
<p>为什么说这是决策树，因为在每个节点上其实都在做决策。</p>
<p>可以将 “路径” 和 “选择” 列表作为决策树上每个节点的属性。</p>
<p>定义的 backtrack 函数其实就像一个指针，在这棵树上游走，同时要正确的维护每个节点的属性，每当走到树的底层，其路径就是一个全排列。</p>
<p>再进一步就是如何遍历一棵树，多叉树的遍历如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        <span class="comment">// 前序遍历需要的操作</span></span><br><span class="line">        traverse(child);</span><br><span class="line">        <span class="comment">// 后序遍历需要的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓的前序遍历和后序遍历，只是两个很有用的时间点。<strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行</strong></p>
<p>“路径”和“选择”是每个节点的属性，函数在树上游走要正确维护节点的属性，就需要在这两个特殊时间点搞点动作。</p>
<p><strong>前序的节点做选择，后序的节点撤销选择</strong></p>
<p>现在再回看回溯算法的核心框架：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径，选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure>

<p><strong>只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径</p>
<p>全排列代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数，输入一组不重复的数字，返回它们的全排列*/</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录路径</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：记录在 track 中</span></span><br><span class="line"><span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line"><span class="comment">// 结束条件：nums 中元素全部在 track 中出现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全排列的 JS 代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> track = [];</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> trackback = <span class="function">(<span class="params">nums, track</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length === track.length) &#123;</span><br><span class="line">            result.push(track.slice());  <span class="comment">// 使用slice方法进行复制</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(track.includes(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            track.push(nums[i]);</span><br><span class="line">            trackback(nums, track);</span><br><span class="line">            track.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trackback(nums, track);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里稍微做了变通，没有显示记录“选择列表”，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表。</p>
<p>这个算法解决全排列不是很高效。但是不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 <code>O(N)</code>，因为穷举整棵决策树是无法避免的。<strong>这是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong></p>
<p><strong>提升</strong></p>
<p>上面是假设数组中没有重复出现的元素，现在将难度进行升级，如果数组中存在重复元素，如何进行全排列，且去除重复的组合</p>
<ul>
<li>首先不能使用 track 来判断是否出现过元素</li>
<li>改用 <code>visited</code> 对象，用来保存是否遍历过 i </li>
<li>用 <code>inclu</code> 数组来去除每次选择时去除重复选择的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> track = [];</span><br><span class="line">    <span class="keyword">const</span> visited = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> backtrack = <span class="function"><span class="keyword">function</span>(<span class="params">nums, track</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (track.length === nums.length) &#123;</span><br><span class="line">            result.push(track.slice());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> inclu = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (inclu.includes(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            inclu.push(nums[i]);</span><br><span class="line">            track.push(nums[i]);</span><br><span class="line">            backtrack(nums, track);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.pop();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span>(<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> track = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> backtrack = <span class="function"><span class="keyword">function</span>(<span class="params">track, start</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (track.length === k) &#123;</span><br><span class="line">            res.push(track.slice());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=start; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (track.includes(i+<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            track.push(i+<span class="number">1</span>);</span><br><span class="line">            backtrack(track, i);</span><br><span class="line">            track.pop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(track, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串大小写全排列"><a href="#字符串大小写全排列" class="headerlink" title="字符串大小写全排列"></a>字符串大小写全排列</h4><p>给定一个字符串<code>S</code>，通过将字符串<code>S</code>中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letterCasePermutation = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> track = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> backtrack = <span class="function"><span class="keyword">function</span>(<span class="params">track, i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>  (track.length === s.length) &#123;</span><br><span class="line">            res.push(track.slice().join(<span class="string">''</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(s[i])) &#123;</span><br><span class="line">            track.push(s[i].toLowerCase());</span><br><span class="line">            backtrack(track, i+<span class="number">1</span>);</span><br><span class="line">            track.pop();</span><br><span class="line"></span><br><span class="line">            track.push(s[i].toUpperCase());</span><br><span class="line">            backtrack(track, i+<span class="number">1</span>);</span><br><span class="line">            track.pop();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            track.push(s[i])</span><br><span class="line">            backtrack(track, i+<span class="number">1</span>);</span><br><span class="line">            track.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    backtrack(track,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、N皇后问题"><a href="#二、N皇后问题" class="headerlink" title="二、N皇后问题"></a>二、N皇后问题</h3><p>给你一个 N*N 的棋盘，让你放置 N 个皇后，使得它们不能相互攻击。</p>
<p>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p>
<p>这个问题本质上跟全排列问题差不多，决策树的每一层标识棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p>
<p>直接套用框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入棋盘边长n，返回所有合法的放置*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// '.'表示空，'Q'表示皇后，初始化空棋盘</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line">    backtrack(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：board 中小于 row 的行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = board[row].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isValid(board, row, col)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        <span class="comment">// 进入下一行决策</span></span><br><span class="line">        backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分主要代码，和全排列问题差不多，<code>isValid</code>函数的实现也很简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*是否可以在 board[row][col] 放置皇后*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.size();</span><br><span class="line">    <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=row<span class="number">-1</span>,j=col+<span class="number">1</span>; i&gt;=<span class="number">0</span>&amp;&amp;j&lt;n; i--,j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=row<span class="number">-1</span>,j=col<span class="number">-1</span>; i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>; i--,j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 <code>backtrack</code> 依然像个在决策树上游走的指针，通过 <code>row</code> 和 <code>col</code> 就可以表示函数遍历到的位置，通过 <code>isValid</code>函数可以将不符合条件的情况剪枝。</p>
<h3 id="三、最后总结"><a href="#三、最后总结" class="headerlink" title="三、最后总结"></a>三、最后总结</h3><p>回溯算法就是多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(...)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(...)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p><strong>写 backtrack 函数时，需要维护走过的路径和当前可以做的选择列表，当触发结束条件时，将路径记入结果集。</strong></p>
<p>回想一下，回溯算法和动态规划。动态规划中，三个需要明确的点就是：状态、选择、base case。对应着就是走过的路径、当前的选择列表和结束条件。</p>
<p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而上面的两个问题都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/滑动窗口算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/滑动窗口算法/" itemprop="url">滑动窗口算法框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="滑动窗口算法框架"><a href="#滑动窗口算法框架" class="headerlink" title="滑动窗口算法框架"></a>滑动窗口算法框架</h2><p>关于双指针的快慢指针和左右指针的用法，可以参考双指针技巧。本文就解决一类最难掌握的双指针技巧：<strong>滑动窗口技巧</strong>。</p>
<p>滑动窗口算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案。</p>
<p>该算法的大致逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法的时间复杂度是 <code>O(N)</code> ，比字符串暴力算法要高效的多</p>
<p>而困扰的不是算法的思路，而是各种细节问题。比如如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的那个阶段更新结果。</p>
<p><strong>滑动窗口算法的代码框架</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*滑动窗口算法框架*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">        <span class="comment">/*debug 输出的位置*/</span></span><br><span class="line">        printf(<span class="string">"window: [%d, %d)\n"</span>, left, right);</span><br><span class="line">        <span class="comment">/******************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中两处 <code>...</code> 表示的更新窗口数据的地方，到时候直接往里面填即可。</p>
<p>而且这两个 <code>...</code> 处的操作分别是右移和左移窗口更新操作，它们的操作是完全对称的。</p>
<p>滑动窗口很多时候都是在处理字符串相关的问题，Java 处理字符串不方便，代码使用 C++ 实现。</p>
<p><code>unordered_map</code> 就是哈希表（字典），它的一个方法 <code>count(key)</code> 相当于 Java 的 <code>containsKey(key)</code> 可以判断键 <code>key</code> 是否存在。</p>
<p>可以使用方括号访问键对应的值 <code>map[key]</code> 。需要注意的是，如果该 <code>key</code> 不存在，C++ 会自动创建这个 key，并将 <code>map[key]</code> 赋值为 0.</p>
<h3 id="一、最小覆盖子串"><a href="#一、最小覆盖子串" class="headerlink" title="一、最小覆盖子串"></a>一、最小覆盖子串</h3><p>leetcode 76 题：给一个字符串 S、一个字符串 T，请在字符串 S 里找出：包含 T 所有字母的最小子串。</p>
<p>即：在 S 中找到包含 T 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p>
<p>如果使用暴力解法，大概是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;s.size(); j++)</span><br><span class="line">        <span class="keyword">if</span> s[i:j] 包含 t 的所有字母:</span><br><span class="line">    		更新答案</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路很直接，但是这样算法的复杂度肯定大于 <code>O(N^2)</code> 了。</p>
<p><strong>滑动窗口的思路：</strong></p>
<ol>
<li>在字符串 <code>S</code> 中使用双指针的左右指针技巧，初始化 <code>left = right = 0</code>，把索引左闭右开区间 <code>[left, right)</code> 称为一个窗口。</li>
<li>先不断的增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code> ，直到窗口中的字符符合要求</li>
<li>此时停止增加 <code>right</code> ，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code> ，直到窗口中的字符串不再符合要求。同时，每次增加 <code>left</code> 都要更新一轮结果。</li>
<li>重复第 2 步和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</li>
</ol>
<p>这个思路其实不难，<strong>第二步相当于在寻找一个可行解，第三步在优化这个可行解，最终找到最优解</strong>，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p>
<p><code>needs</code> 和 <code>window</code> 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。</p>
<p><strong>现在看看这个滑动窗口代码框架的使用</strong>：</p>
<p>首先，初始化 <code>window</code> 和 <code>need</code> 两个哈希表，记录窗口中的字符和需要凑齐的字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c:t) need[c]++;</span><br></pre></td></tr></table></figure>

<p>然后使用 <code>left</code> 和 <code>right</code> 变量初始化窗口的两端，不要忘记，区间 <code>[left, right)</code> 是左闭右开的，所以初始情况下窗口没有包含任何元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 开始滑动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中 <code>valid</code> 变量表示窗口中满足 <code>need</code> 条件的字符个数</strong>，如果 <code>valid</code> 和 <code>need.size()</code> 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 T。</p>
<p>只需思考以下四个问题：</p>
<ol>
<li>当移动 <code>right</code> 扩大窗口，即加入字符时，应该更新哪些数据</li>
<li>什么条件下，窗口应该暂停扩大，开始移动 <code>left</code> 缩小窗口</li>
<li>当移动 <code>left</code> 缩小窗口，即移除字符时，应该更新哪些数据</li>
<li>需要的结果应该在扩大窗口时还是缩小窗口时进行更新。</li>
</ol>
<p>如果一个字符进入窗口，应该增加 <code>window</code> 计数器；如果一个字符将移除窗口的时候，应该减少 <code>window</code> 计数器；当 <code>valid</code> 满足 <code>need</code> 时应该收缩窗口；应该在收缩创就的时候更新结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    unordered_mp&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">            <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最小覆盖子串</span></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ? <span class="string">""</span> : s.substr(start,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，当发现某个字符在 <code>window</code> 的数量满足了 <code>need</code> 的需要，就要更新 <code>valid</code> ，表示有一个字符已经满足要求。而且两次对窗口内数据的更新操作时完全对称的。</p>
<p>当 <code>valid == need.size()</code>时，说明 <code>T</code> 中字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该收缩窗口了，以便得到最小覆盖子串。</p>
<p>移动 <code>left</code> 收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。</p>
<h3 id="二、字符串排列"><a href="#二、字符串排列" class="headerlink" title="二、字符串排列"></a>二、字符串排列</h3><p>leetcode 567 题：给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。</p>
<p>注意：输入的 <code>s1</code> 时可以包含重复字符的。</p>
<p>这是明显的滑动窗口算法，<strong>相当于给一个 S 和一个 T，问 S 中是否存在一个子串，包含 T 中的所有字符且不包含其它字符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 s 中是否有 t 的排列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> t, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (need[c] == window[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.size()) &#123;</span><br><span class="line">            <span class="comment">// 判断是否找到合法的子串</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (need[d] == window[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题的解法代码，基本上跟最小覆盖子串一模一样，只需要改变两个地方。</p>
<ol>
<li>本题移动 <code>left</code> 缩小窗口的时机是窗口大小大于 <code>t.size()</code> 时，排列显然长度应该是一样的</li>
<li>当发现 <code>valid == need.size()</code> 时，就说明窗口中就是一个合法的排列，所以立即返回 <code>true</code></li>
</ol>
<p>附加：JS 代码实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> checkInclusion = <span class="function"><span class="keyword">function</span> (<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">window</span> = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">const</span> need = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> s1) need.set(c, need.has(c) ? need.get(c) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right &lt; s2.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> c = s2[right];</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新数据</span></span><br><span class="line">    <span class="keyword">if</span> (need.has(c)) &#123;</span><br><span class="line">      <span class="built_in">window</span>.set(c, <span class="built_in">window</span>.has(c) ? <span class="built_in">window</span>.get(c) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.get(c) == need.get(c)) &#123;</span><br><span class="line">        valid++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right - left &gt;= s1.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (valid == need.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> d = s2[left];</span><br><span class="line">      left++;</span><br><span class="line">      <span class="keyword">if</span> (need.has(d)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.get(d) == need.get(d)) &#123;</span><br><span class="line">          valid--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">window</span>.set(d, <span class="built_in">window</span>.get(d) - <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三、找出所有字母异位词"><a href="#三、找出所有字母异位词" class="headerlink" title="三、找出所有字母异位词"></a>三、找出所有字母异位词</h3><p>leetcode 438 题：给定一个字符串 s 和一个非空字符串 p，找到 s 中所有事 p 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>（字母异位词指字母相同，但排列不同的字符串）</p>
<p><strong>相当于，输入一个串 S ，一个串 T ，找到 S 中所有 T 的排列，返回它们的起始索引</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> t) &#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c:t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= t.size()) &#123;</span><br><span class="line">            <span class="comment">// 当窗口符合条件时，把起始索引加入 res</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.size()) &#123;</span><br><span class="line">                res.push_back(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入 <code>res</code> 即可。</p>
<h3 id="四、最长无重复子串"><a href="#四、最长无重复子串" class="headerlink" title="四、最长无重复子串"></a>四、最长无重复子串</h3><p>leetcode 3 题：给定一个字符串，找出其中不含有重复字符的最长子串的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        window[c]++;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里更新答案</span></span><br><span class="line">        res = max(res, right-left)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是变得简单了，连 <code>need</code> 和 <code>valid</code> 都不需要，而且更新窗口内数据也只需要简单的更新计数器 window 即可。</p>
<p>当 <code>window[c]</code> 值大于 1 时，说明窗口中年存在重复字符，不符合条件，就该移动 <code>left</code> 缩小窗口</p>
<p>唯一需要注意的是在哪里更新结果 <code>res</code> 。这里要在收缩窗口完成后更新 <code>res</code> ，因为窗口收缩的 <code>while</code> 条件是存在重复元素，也就是收缩完成后一定保证窗口中没有重复。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/后序遍历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/后序遍历/" itemprop="url">后序遍历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>二叉树的题目，无非就是前中后序遍历来回倒，但对于有的题目，不同的遍历顺序，复杂度不同。</p>
<p><strong>二叉树相关的题目最核心的思路就是明确当前节点需要做的事情是什么</strong>。</p>
<p>后序遍历的代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">/*后序遍历代码的位置*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历出现的位置，<strong>如果当前节点要做的事需要通过左右子树的计算结果推导出来，就要用到后序遍历</strong>。</p>
<p>例如：leetcode 1373 题：二叉搜索子树的最大键值和。</p>
<p>输入一棵二叉树，这颗二叉树的子树可能包含二叉搜索树，返回它的节点值之和。</p>
<p>二叉树相关题目最核心的思路就是<strong>明确当前节点要做的事情是什么</strong></p>
<p>如果想计算子树中 BST 最大和，站在当前节点的视角，需要做什么？</p>
<ul>
<li>首先得知道左右子树是否是合法的 BST </li>
<li>然后左右子树加上本身节点还是不是合法的 BST 因为题目要计算最大的节点之和，如果左右子树加上自身还是一棵合法的 BST ，那么就需要知道这棵 BST 的所有结点值之和。方便进行比较。</li>
</ul>
<p><strong>根据以上三点，站在当前结点的视角，需要知道以下具体信息</strong></p>
<ul>
<li>左右子树是否是 BST</li>
<li>左子树的最大值和右子树的最小值</li>
<li>左右子树的结点值之和</li>
</ul>
<p>只有知道这几个值，才能满足题目的要求，想方法计算这些值</p>
<p>尝试用伪码写出算法的大致逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，记录 BST 最大节点之和</span></span><br><span class="line"><span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*遍历二叉树*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***** 前序遍历位置 *****/</span></span><br><span class="line">    <span class="comment">// 判断左右子树是不是 BST</span></span><br><span class="line">    <span class="keyword">if</span> (!isBST(root.left) || !isBST(root.right)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算左子树最大值和右子树最小值</span></span><br><span class="line">    <span class="keyword">int</span> leftMax = findMax(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMin = findMin(root.right);</span><br><span class="line">    <span class="comment">// 判断以 root 节点为根的树是不是 BST</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= leftMax || root.val &gt;= rightMin) &#123;</span><br><span class="line">        <span class="keyword">goto</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果条件都符合，计算当前 BST 的节点之和</span></span><br><span class="line">    <span class="keyword">int</span> leftSum = findSum(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightSum = findSum(root.right);</span><br><span class="line">    <span class="keyword">int</span> rootSum = leftSum + rightSum + root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算 BST 节点的最大和</span></span><br><span class="line">    <span class="keyword">this</span>.maxSum = Math.max(maxSum, rootSum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归遍历左右子树</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算以 root 为根的二叉树的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(TreeNode root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算以 root 为根的二叉树的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(TreeNode root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算以 root 为根的二叉树的节点和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSum</span><span class="params">(TreeNode root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断以 root 为根的二叉树是否是 BST</span></span><br><span class="line"><span class="function">boolean <span class="title">isBST</span><span class="params">(TreeNode root)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码逻辑是不难理解的，代码在前序遍历的位置将之前的分析都实现了一遍。</p>
<p><strong>稍作分析就会发现，这几个辅助函数都是递归函数，都要遍历输入的二叉树，外加 reverse 函数本身的递归，这个解法的时间复杂度是非常高的。</strong></p>
<p>其实只要将前序遍历变成后序遍历，让 reverse 函数将辅助函数的事情顺便做了就好。</p>
<p>其它代码不变，让 reverse 函数做一些计算任务，返回一个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] traverse(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] left = traverse(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = traverse(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/********* 后序遍历位置 ***************/</span></span><br><span class="line">    <span class="comment">// 通过 left 和 right 推导返回值</span></span><br><span class="line">    <span class="comment">// 正确更新 maxSum 变量</span></span><br><span class="line">    <span class="comment">/************************************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>traverse(root)</code> 返回一个大小为 4 的 int 数组，暂且称它为 <code>res</code> ，其中：</p>
<ul>
<li><code>res[0]</code>记录以 root 为根的二叉树是否是 BST ，若为 1 则说明是 BST，若为 0 则说明不是 BST；</li>
<li><code>res[1]</code>记录以 root 为根的二叉树所有节点中的最小值</li>
<li><code>res[2]</code>记录以 root 为根的二叉树所有节点中的最大值</li>
<li><code>res[3]</code> 记录以 root 为根的二叉树所有节点值之和</li>
</ul>
<p>其实就是将之前的几个值放到了 <code>res</code> 数组中，<strong>最重要的是试图通过 <code>left</code> 和 <code>right</code> 正确推导出 res 数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] traverse(TreeNode root) &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归计算左右子树</span></span><br><span class="line">    <span class="keyword">int</span>[] left = traverse(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = traverse(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/******** 后序遍历位置 *********/</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 这个 if 在判断以 root 为根的二叉树是不是 BST</span></span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 以 root 为根的二叉树是 BST</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算以 root 为根的 BST 最小值</span></span><br><span class="line">        res[<span class="number">1</span>] = Math.min(left[<span class="number">1</span>], root.val);</span><br><span class="line">        <span class="comment">// 计算以 root 为根的 BST 最大值</span></span><br><span class="line">        res[<span class="number">2</span>] = Math.max(right[<span class="number">2</span>], root.val);</span><br><span class="line">        <span class="comment">// 计算以 root 为根的 BST 节点之和</span></span><br><span class="line">        res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">        <span class="comment">// 更新全局变量</span></span><br><span class="line">        maxSum = Math.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 以 root 为根的二叉树不是 BST</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 其它值没必要计算了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，这道题就解决了，traverse 函数在遍历二叉树的同时顺便将之前辅助函数做的事做了，避免了在递归函数中调用递归函数，时间复杂度只有 <code>O(N)</code></p>
<p>后序遍历在这种，当前节点要做的事需要左右子树的计算结果推导出来时，更加简洁、效率。</p>
<p>JS 实现代码（有问题）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSumBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> traverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左右子树是否是 BST</span></span><br><span class="line">        <span class="keyword">if</span> (!isBST(root.left) || !isBST(root.right)) &#123;</span><br><span class="line">            traverse(root.left);</span><br><span class="line">            traverse(root.right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左子树最大值和右子树最小值</span></span><br><span class="line">        <span class="keyword">const</span> leftMax = findMax(root.left);</span><br><span class="line">        <span class="keyword">const</span> rightMin = findMin(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= leftMax || root.val &gt;= rightMin) &#123;</span><br><span class="line">            traverse(root.left);</span><br><span class="line">            traverse(root.right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左右子树节点值</span></span><br><span class="line">        <span class="keyword">const</span> leftSum = sumNode(root.left);</span><br><span class="line">        <span class="keyword">const</span> rightSum = sumNode(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> sum = leftSum + rightSum + root.val;</span><br><span class="line">        maxSum = <span class="built_in">Math</span>.max(sum, maxSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBST2(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> isBST2 = <span class="function"><span class="keyword">function</span>(<span class="params">root, max, min</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isBST2(root.left, root, min) &amp;&amp; isBST2(root.right, max, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> findMax = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> max = <span class="built_in">Number</span>.MIN_VALUE;        </span><br><span class="line">        <span class="keyword">const</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">            max = <span class="built_in">Math</span>.max(max, root.val);</span><br><span class="line">            reverse(root.right);</span><br><span class="line">            reverse(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> findMin = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> min = <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">        <span class="keyword">const</span> traverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">            min = <span class="built_in">Math</span>.min(min, root.val);</span><br><span class="line">            traverse(root.left);</span><br><span class="line">            traverse(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> sumNode = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> traverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">            sum+= root.val;</span><br><span class="line">            traverse(root.left);</span><br><span class="line">            traverse(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSumBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxSum = <span class="built_in">Number</span>.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> traverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>, <span class="built_in">Number</span>.MIN_VALUE, <span class="built_in">Number</span>.MAX_VALUE, <span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> left = traverse(root.left);</span><br><span class="line">        <span class="keyword">const</span> right = traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 判断这个 root 为根节点的二叉树是不是 BST</span></span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] === <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] === <span class="number">1</span> &amp;&amp; left[<span class="number">1</span>] &lt; root.val &amp;&amp; right[<span class="number">2</span>] &gt; root.val) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = <span class="built_in">Math</span>.max(left[<span class="number">1</span>], root.val);</span><br><span class="line">            res[<span class="number">2</span>] = <span class="built_in">Math</span>.min(right[<span class="number">2</span>], root.val);</span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line"></span><br><span class="line">            maxSum = <span class="built_in">Math</span>.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSumBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> max=<span class="number">0</span>;</span><br><span class="line"> dfs(root)</span><br><span class="line"> <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 计算二叉树最大和</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 四元组分别表示当前子树为二叉搜索树、子树最小值、子树最大值，</span></span><br><span class="line">   <span class="comment">// 以及当前二叉搜索树数值求和</span></span><br><span class="line">   <span class="keyword">if</span>(!root) <span class="keyword">return</span> [<span class="literal">true</span>,<span class="literal">Infinity</span>,-<span class="literal">Infinity</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> left=dfs(root.left)</span><br><span class="line">   <span class="keyword">const</span> right=dfs(root.right)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> sum=<span class="number">0</span>,curMax,curMin;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 判断是否为二叉搜索树。当前节点比左子树最大值小或者比右子树最小值大都不是搜索树</span></span><br><span class="line">   <span class="keyword">if</span>(!left[<span class="number">0</span>]||!right[<span class="number">0</span>] </span><br><span class="line">      || root.val&lt;=left[<span class="number">2</span>]||root.val&gt;=right[<span class="number">1</span>])&#123;</span><br><span class="line">       <span class="keyword">return</span> [<span class="literal">false</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 包含当前节点的二叉搜索树中节点值范围[左子树最小值,右子树最大值]</span></span><br><span class="line">   curMin=root.left?left[<span class="number">1</span>]:root.val;</span><br><span class="line">   curMax=root.right?right[<span class="number">2</span>]:root.val;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 先计算临时和，再与当前最大和比较。类似数组求最大和的过程</span></span><br><span class="line">   sum+=left[<span class="number">3</span>]+right[<span class="number">3</span>]+root.val;</span><br><span class="line">   max=<span class="built_in">Math</span>.max(max,sum)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> [<span class="literal">true</span>,curMin,curMax,sum]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/二分查找详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/二分查找详解/" itemprop="url">二分查找详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。而且要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，可以灵活准确的写出正确的二分查找算法。</p>
<h3 id="一、二分查找框架"><a href="#一、二分查找框架" class="headerlink" title="一、二分查找框架"></a>一、二分查找框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析二分查找的一个技巧是：不要出现 else，而是将所有情况用 else if 写清楚，这样可以清楚的展现所有细节</strong>。</p>
<p>其中 <code>...</code> 出现的部分，就是可能出现细节问题的地方，当遇到一个二分查找的代码时，首先注意这些地方。</p>
<p>另外，计算 <code>mid</code> 时需要防止溢出，代码中 <code>left + (right - left)/2</code> 就和 <code>(left + right) /2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大直接相加导致溢出。</p>
<h3 id="二、寻找一个数（基本的二分搜索）"><a href="#二、寻找一个数（基本的二分搜索）" class="headerlink" title="二、寻找一个数（基本的二分搜索）"></a>二、寻找一个数（基本的二分搜索）</h3><p>搜索一个数，如果存在，返回其索引，否则返回 -1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1. 为什么 while 循环的条件时 &lt;= ，而不是 &lt;</strong></p>
<p>因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。</p>
<p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭的区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。</p>
<p>这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。<strong>这个区间其实就是每次进行搜索的区间</strong>。</p>
<p>找到目标值的时候就可以终止搜索。但如果没找到，就需要 while 循环终止，返回 -1. 当<strong>搜索区间为空的时候应该终止</strong>，意味着没得找了，就等于没找到。</p>
<p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right+1</code>，写出区间的形式就是 <code>[right+1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有数字既大于3又小于等于2。所以这时候 while 循环终止是正确的，直接返回 -1 即可</p>
<p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[right, right]</code>，这时候区间非空，但此时 while 循环终止了。会漏了一个索引，这时候直接返回 -1 就是错误的。</p>
<p>如果非要用 <code>while(left&lt;right)</code>也可以，因为知道了原因，打个补丁就可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] === target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2. 为什么 <code>left = mid + 1</code>, <code>right = mid - 1</code>? 有的代码是 <code>right = mid</code> 或者 <code>left = mid</code></strong></p>
<p>这也是二分查找的一个难点，但只要理解前面内容，就很容易判断。</p>
<p>刚刚明确了搜索区间的概念，且本算法的搜索区间两端都是闭的，即 <code>[left, right]</code>。那么当发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，应该去搜索哪里。<strong>因为 <code>mid</code> 已经搜索过，所以应该从搜索区间去除</strong>，搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code></p>
<p><strong>3. 该算法有什么缺陷</strong></p>
<p>这个算法存在局限性。</p>
<p>比如说给一个有序数组 <code>nums = [1, 2, 2, 2, 3]</code>，<code>target</code> 为2，此算法返回的索引是 2。但是如果想得到 <code>target</code> 的左侧边界，即索引 1，或者想得到 <code>target</code> 的右侧边界，即索引 3，这样的话，此算法是无法处理的。</p>
<p>这样的需求很常见，<strong>也许可以找到一个 target，然后向左或向右线性线性搜索，但是这样难以保证二分查找对数级的复杂度了</strong>。</p>
<p>后续的算法就讨论这两种二分查找的算法。</p>
<h3 id="二、寻找左侧边界的二分搜索"><a href="#二、寻找左侧边界的二分搜索" class="headerlink" title="二、寻找左侧边界的二分搜索"></a>二、寻找左侧边界的二分搜索</h3><p>以下是最常见的代码形式，其中的标记是需要注意的细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;<span class="comment">// 注意</span></span><br><span class="line">    	<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1. 为什么 while 中是 &lt; 而不是 &lt;=</strong></p>
<p>用相同的方法分析，因为 <code>right = nums.length</code> 而不是 <code>nuums.length - 1</code>. 因此每次循环的搜索区间是 <code>[left, right)</code>左闭右开。</p>
<p><code>while(left&lt;right)</code>终止条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code>为空，所以可以正确终止。</p>
<p>PS：这里先要说一个搜索左右边界和上面这个算法的一个区别：<strong>刚才的 <code>right</code> 是 <code>nums.length-1</code> ， 而这里是 <code>nums.length</code>，使得搜索区间变成左闭右开</strong>。</p>
<p>因为对于搜索左右边界的二分查找，这种写法比较普遍。如果用两端都闭得写法反而更简单，后面会用一种两端都闭得写法将三种二分搜索统一起来。</p>
<p><strong>2. 为什么没有返回 -1 的操作，如果 <code>nums</code> 中不存在 <code>target</code> 值怎么办</strong></p>
<p>对于 <code>nums = [1, 2, 2, 2, 3], target = 2</code> 这个数组，算法会返回 1.这个 1 的含义可以这样解读：<code>nums</code> 中小于 2 的元素有 1 个。</p>
<p>比如对于有序数组 <code>nums = [2, 3, 5, 7], target = 1</code>，算法会返回 0，含义是：<code>nums</code>中小于 1 的元素有 0 个。</p>
<p>再比如 <code>nums = [2, 3, 5, 7], target=8</code>，算法会返回 4，含义是：<code>nums</code> 中小于 8 的元素有 4 个。</p>
<p>综上，函数的返回值（即 left 变量的值）取值区间是闭区间 <code>[0, nums.length]</code>，所以简单的提炼两行代码就能在正确的时候 <code>return -1</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// target 比所有数都大</span></span><br><span class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 类似之前算法的处理方式</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3. 为什么 left = mid + 1, right = mid，和之前的算法不一样</strong></p>
<p>这是因为搜索区间是 <code>[left, right)</code>左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉mid 分割成两个区间，即 <code>[left, mid)</code>或 <code>[mid+1, right)</code></p>
<p><strong>4. 为什么该算法能够搜索左侧边界</strong></p>
<p>关键在于对 <code>nums[mid] == target</code>, 这种情况的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">    right = mid;</span><br></pre></td></tr></table></figure>

<p>可见找到 target 时不立即返回，而是缩小搜索区间的上界 <code>right</code>，在区间 <code>[left, mid)</code>中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p>
<p><strong>5. 为什么返回 left 而不是 right</strong></p>
<p>都是一样的，因为 while 的终止条件时 <code>left == right</code></p>
<p><strong>6. 能不能想办法将 <code>right</code> 变成 <code>nums.length - 1</code>， 也就是继续使用两边都闭得搜索区间，这样就可以和第一种二分搜索某种程度上统一起来</strong></p>
<p>只要明白搜索区间的概念，就能有效避免漏掉元素。</p>
<p>如果要让搜索区间两端都闭， <code>right</code>应该初始化为 <code>nums.length - 1</code>，while 的终止条件时 <code>left == right+1</code>，也就是其中应该用 <code>&lt;=</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// if else</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为搜索区间时两端都闭的，且现在是搜索左侧边界，所以 <code>left</code> 和 <code>right</code> 的更新逻辑如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    <span class="comment">// 收缩右侧边界</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">    <span class="comment">// 搜索区间变为 [left, mid - 1]</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 while 的退出条件是 <code>left == right + 1</code>，所以当 <code>target</code> 比 <code>numms</code> 中所有元素都大时，会存在索引越界。</p>
<p>所以最后返回结果的代码应该检查越界情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure>

<p>至此，完整的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相似题目：</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> solution = <span class="function"><span class="keyword">function</span>(<span class="params">isBadVersion</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;integer&#125; n Total versions</span></span><br><span class="line"><span class="comment">     * @return &#123;integer&#125; The first bad version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">const</span> mid = left + <span class="built_in">Math</span>.floor((right - left)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; n || !isBadVersion(left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="四、寻找右侧边界的二分查找"><a href="#四、寻找右侧边界的二分查找" class="headerlink" title="四、寻找右侧边界的二分查找"></a>四、寻找右侧边界的二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="comment">// if (left &gt;= nums.length || nums[left] != target)</span></span><br><span class="line">    <span class="comment">//    return -1;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里改为检查 right 越界情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因为收紧左侧边界时必须 left = mid + 1，所以最后无论返回 left 还是 right，唏嘘减一</strong></p>
<h4 id="PS：为什么查左侧边界要考虑-left-越界，右侧边界要考虑-right-越界？"><a href="#PS：为什么查左侧边界要考虑-left-越界，右侧边界要考虑-right-越界？" class="headerlink" title="PS：为什么查左侧边界要考虑 left 越界，右侧边界要考虑 right 越界？"></a>PS：为什么查左侧边界要考虑 left 越界，右侧边界要考虑 right 越界？</h4><h3 id="四、逻辑统一"><a href="#四、逻辑统一" class="headerlink" title="四、逻辑统一"></a>四、逻辑统一</h3><p>梳理一下这些细节差异的因果逻辑</p>
<p><strong>第一个，最基本的二分查找算法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">因为初始化 right = nums.length - 1</span><br><span class="line">所以决定了搜索区间是 [left, right]</span><br><span class="line">所以决定了 while(left &lt;= right)</span><br><span class="line">同时也决定了 left = mid + 1, right = mid - 1</span><br><span class="line"></span><br><span class="line">只需要找到一个 target 的索引</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br></pre></td></tr></table></figure>

<p><strong>第二个，寻找左侧边界的二分查找</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">因为初始化 right = nums.length</span><br><span class="line">所以决定了搜索区间时 [left, right)</span><br><span class="line">所以决定了 while(left &lt; right)</span><br><span class="line">同时也决定了 left = mid + 1, right = mid</span><br><span class="line"></span><br><span class="line">因为需要找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure>

<p>第三个，寻找右侧边界的二分查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">因为初始化 right = nums.length</span><br><span class="line">所以决定了搜索区间时 [left, right)</span><br><span class="line">所以决定了 while(left &lt; right)</span><br><span class="line">同时也决定了 left = mid + 1, right = mid</span><br><span class="line"></span><br><span class="line">因为需要找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而是要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 left = mid + 1</span><br><span class="line">所以最后无论返回 left 还是 right，必须减一</span><br></pre></td></tr></table></figure>

<p>对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的搜索区间。<strong>还根据逻辑将搜索区间全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后检查 left 越界情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后检查 right 越界情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过本文，可以得到：</p>
<ol>
<li>分析二分查找代码时，不要使用 else，全部展开成 else if 便于理解</li>
<li>注意搜索区间和 while 的终止条件，如果存在漏掉的元素，记得在最后检查</li>
<li>如果需定义左闭右开的搜索区间搜索左右边界，只要在 <code>nums[mid] == target</code> 时做修改即可，搜索右侧时需要减一</li>
<li>如果将搜索区间全部统一成两端都闭，好记，只要稍改 <code>nums[mid] == target</code>条件处的代码和返回逻辑即可。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/二叉搜索树（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/二叉搜索树（一）/" itemprop="url">二叉搜索树（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二叉搜索树（一）"><a href="#二叉搜索树（一）" class="headerlink" title="二叉搜索树（一）"></a>二叉搜索树（一）</h2><p>二叉搜索树（Binary Search Tree） ，简称  BST 。</p>
<p>BST 的特性：</p>
<ol>
<li>对于 BST 每一个节点 node ，左子树节点的值都比 node 的值要小，右子树节点的值都比 node 的值大。</li>
<li>对于 BST 每一个节点 node，它的左侧子树和右侧子树都是 BST。</li>
</ol>
<p>二叉搜索树并不复杂，但是很多数据结构都是基于 BST 的。比如 AVL 树，红黑树等等。拥有自平衡性质，可以提供您 log N 级别的增删改查效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。</p>
<p><b>从做算法题的角度来看 BST ，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）</b></p>
<p>也就是说，如果输入一棵 BST ，以下代码可以将 BST 中每个节点的值升序打印出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">	traverse(root.left);</span><br><span class="line">	<span class="comment">// 中序遍历代码位置</span></span><br><span class="line">	print(root.val);</span><br><span class="line">	traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据这个性质，我们可以做两道算法题</p>
<h4 id="1-寻找第-K-小的元素"><a href="#1-寻找第-K-小的元素" class="headerlink" title="1. 寻找第 K 小的元素"></a>1. 寻找第 K 小的元素</h4><p>leetcode 230题：</p>
<p>给定一个二叉搜索树，编写一个函数来查找其中第 k 个最小的元素。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k=3</span><br><span class="line">		5</span><br><span class="line">	   / \</span><br><span class="line">	  3   6</span><br><span class="line">	 / \</span><br><span class="line">	2   4</span><br><span class="line">   /</span><br><span class="line">  1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>思路就是利用 BST 的中序遍历是一个升序的过程来找到第 k 个元素。可以直接写出代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        kthSmallest(root.left, k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            result = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        kthSmallest(root.right, k);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这个解法并不是最高效的解法，仅仅只是适用于这道题。</p>
<p>每次寻找第 k 小的元素都要中序遍历一次，最坏的时间复杂度是 O(N)，N 是 BST 的节点个数。</p>
<p>BST 的性质很强，像红黑树这种改良的自平衡 BST ，增删改查都是 O(log N) 的复杂度，算一个第 k 小元素，时间复杂度竟然要 O(N)，这就有些低效了。</p>
<p>所以说，计算第 k 小元素，最好的算法肯定也是对数级别的复杂度，不过这个依赖 BST 节点记录的信息有多少。</p>
<p>BST 高效的原因是：<strong>所有节点都可以通过对比自身的值判断去左子树还是右子树搜索目标值，从而避免全树的遍历，达到对数级复杂度</strong>。</p>
<p>回到这个问题，想找到第 k 小的元素，如果想达到对数级复杂度，关键也在于每个节点得知道他自己排第几。</p>
<p>比如，当前节点知道自己排名 m ，我们可以比较 m 和 k 的大小：</p>
<ul>
<li>如果 m == k，显然就是找到了第 k 个元素，返回当前节点就行了；</li>
<li>如果 k &lt; m，说明排名第 k 的元素在左子树，去左子树搜索；</li>
<li>如果 k &gt; m，说明排名第 k 的元素在右子树，去右子树搜索；</li>
</ul>
<p>这样就可以将时间复杂度降到 O(log N) 了。</p>
<p>如何让每个节点知道自己的排名呢？</p>
<p>这就需要在二叉树节点中维护额外信息。<strong>每个节点需要记录，以自己为根的这颗二叉树有多少个节点</strong>。</p>
<p>TreeNode 中的字段应该如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="comment">// 以该节点为根的树的节点总数</span></span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	TreeNode left;</span><br><span class="line">	TreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了 size 字段，外加 BST 左小右大的性质，对每个节点 node 可以通过 <code>node.left.size</code> 得到 node 的排名，从而做到对数级算法。</p>
<h4 id="2-BST-转换累加树"><a href="#2-BST-转换累加树" class="headerlink" title="2. BST 转换累加树"></a>2. BST 转换累加树</h4><p>leetcode 538 和 1038 题：</p>
<p>给出二叉搜索树的根节点，该树的节点值各不相同，将其转换为累加树，使每个节点 node 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>即：累加树的每个节点值为所有值中大于等于该点值得总和。</p>
<p>签名函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeNode convertBST(TreeNode root);</span><br></pre></td></tr></table></figure>

<p>按照二叉树得通用思路，需要考虑每个节点应该做什么，但是这道题很难想到什么思路。</p>
<p>BST 是左小右大的，既然累加和是计算大于等于当前值的所有元素之和，那么每个节点都去计算右子树的和，不就行了。但是这是不行的，因为父节点也可能比他大。</p>
<p>利用 BST 的中序遍历特性。BST 的中序遍历代码可以升序打印节点的值。如果想降序，只需要将递归的顺序改一下即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 先递归遍历右子树</span></span><br><span class="line">	traverse(root.right);</span><br><span class="line">	<span class="comment">// 中序遍历代码位置</span></span><br><span class="line">	print(root.val);</span><br><span class="line">	<span class="comment">// 后递归遍历左子树</span></span><br><span class="line">	traverse(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这段代码可以从大到小降序打印 BST 节点的值，如果维护一个外部变量 sum，然后将 sum 赋值给 BST 中的每一个节点，就将 BSt 转化成累加树了</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录累加和</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    sum += root.val;</span><br><span class="line">    root.val = sum;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心还是 BST 的中序遍历特性，只不过修改了递归的顺序，降序遍历 BST 的元素值，从而契合题目累加树的要求。</p>
<p><strong>总结：</strong>BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/二叉搜索树（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/二叉搜索树（三）/" itemprop="url">二叉搜索树（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二叉搜索树（三）"><a href="#二叉搜索树（三）" class="headerlink" title="二叉搜索树（三）"></a>二叉搜索树（三）</h2><p>之前两篇，一篇是中序遍历对 BST 的重要意义，另一篇是 BST 的基本操作。</p>
<p>两道题，如何计算所有合法 BST。</p>
<h3 id="一、不同的二叉搜索树"><a href="#一、不同的二叉搜索树" class="headerlink" title="一、不同的二叉搜索树"></a>一、不同的二叉搜索树</h3><p>给一个整数 n ，求给由 n 个节点组成且节点值从 1 到 n 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意得二叉搜索树得种数。即，存储 <code>{1,2,3,...,n}</code> 这些值共有多少种不同的 BST 结构。</p>
<p>签名函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>比如输入 n=3 ，算法返回 5，因为共有 5 种不同的 BST 结构存储 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = 3 时有如下 5 种不同的 BST 结果：</span><br><span class="line"> 1              3      3         2       1</span><br><span class="line">  \            /      /         / \       \</span><br><span class="line">   3          2      1         1   3       2</span><br><span class="line">  /          /        \                     \</span><br><span class="line"> 2          1          2                     3</span><br></pre></td></tr></table></figure>

<p>这就是一个正宗的穷举问题，如何正确的穷举合法 BST 的数量。</p>
<p>举个例子，比如给算法输入 n = 5, 即用 {1, 2, 3, 4 5} 这些数字去构造 BST。每个数字都可以作为根节点，</p>
<p>比如固定 3 作为根节点，这个前提下，根据 BST 特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。所以固定 3 作为根节点，左子树节点就是 {1, 2} 的组合，右子树就是 {4, 5} 的组合。<strong>左子树和右子树组合数的乘积</strong>就是 3 作为根节点时的 BST 个数。</p>
<p>如何让算法进行计算，借助递归即可，可以写这样一个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：闭区间 [lo, hi] 的数字能组成 count(lo, hi) 种 BST</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>;</span><br></pre></td></tr></table></figure>

<p>根据这个函数的定义，可以写出代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算区间 [lo, hi] 组成的 BST 个数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// base case</span></span><br><span class="line">	<span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=lo; i&lt;=hi; i++) &#123;</span><br><span class="line">		<span class="comment">// i 的值作为根节点 root</span></span><br><span class="line">		<span class="keyword">int</span> left = count(lo, i-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> right = count(i+<span class="number">1</span>, hi);</span><br><span class="line">		<span class="comment">// 左右子树的组合数的乘积时 BST 的总数</span></span><br><span class="line">		res += left*right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：base case，显然当 lo &gt; hi 闭区间 [lo, hi] 肯定是个空区间，也就是对应的空节点 null，虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0。</p>
<p>这种，题目的要求已经实现了，但是肯定存在重叠子问题。</p>
<p>动态规划相关的问题种消除重叠子问题的方法，就是加一个备忘录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line"><span class="keyword">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 备忘录的值初始化为0</span></span><br><span class="line">	memo = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 查备忘录</span></span><br><span class="line">	<span class="keyword">if</span> (memo[lo][hi] != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> memo[lo][hi];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i&lt;=hi; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> left = count(lo, i-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> right = count(i+<span class="number">1</span>, hi);</span><br><span class="line">		res += left*right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将结果存入备忘录</span></span><br><span class="line">	memo[lo][hi] = res;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，这题就完全解决了。</p>
<p>一个进阶的题目，不止计算有几个不同的 BST，而是要构建出所有合法的 BST，如何实现。</p>
<h3 id="二、不同的二叉树-Ⅱ"><a href="#二、不同的二叉树-Ⅱ" class="headerlink" title="二、不同的二叉树 Ⅱ"></a>二、不同的二叉树 Ⅱ</h3><p>构建所有 BST，签名函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;TreeNode&gt; <span class="title">generateTree</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>比如说输入 n=3 ，算法返回一个列表，列表中存储着五颗 BST 的根节点。</p>
<p>明白了上道题构造合法 BST 的方法，这题思路也是一样：</p>
<ol>
<li>穷举 root 节点的所有可能</li>
<li>递归构造出左右子树的所有合法 BST</li>
<li>给 root 节点穷举所有左右子树的组合</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="comment">// 构造闭区间 [1, n] 组成的 BST</span></span><br><span class="line">	<span class="keyword">return</span> build(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造闭区间 [lo, hi] 组成的 BST */</span></span><br><span class="line"><span class="function">List&lt;TreeNode&gt; <span class="title">build</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">		res.add(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1. 穷举 root 节点的所有可能性</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=lo; i&lt;=hi; i++) &#123;</span><br><span class="line">		<span class="comment">// 2. 递归构造出左右子树的所有合法 BST</span></span><br><span class="line">		List&lt;TreeNode&gt; leftTree = build(lo, i-<span class="number">1</span>);</span><br><span class="line">		List&lt;TreeNode&gt; rightTree = build(i+<span class="number">1</span>, hi);</span><br><span class="line">		<span class="comment">// 3. 给 root 节点穷举所有左右子树的组合</span></span><br><span class="line">		<span class="keyword">for</span> (TreeNode left : leftTree) &#123;</span><br><span class="line">			<span class="keyword">for</span> (TreeNode right : rightTree) &#123;</span><br><span class="line">				<span class="comment">// i 作为根节点 root 的值</span></span><br><span class="line">				TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">				root.left = left;</span><br><span class="line">				root.right = right;</span><br><span class="line">				res.add(root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/二叉搜索树（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/二叉搜索树（二）/" itemprop="url">二叉搜索树（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二叉搜索树（二）"><a href="#二叉搜索树（二）" class="headerlink" title="二叉搜索树（二）"></a>二叉搜索树（二）</h2><p>之前主要是利用二叉搜索树的中序遍历的有序性来解决问题，本文记录实现 BST 的基础操作：判断 BST 的合法性、增、删、查。</p>
<h3 id="一、判断-BST-的合法性"><a href="#一、判断-BST-的合法性" class="headerlink" title="一、判断 BST 的合法性"></a>一、判断 BST 的合法性</h3><p>按照之前的思路，每个节点自己要做的事就是比较自己和左右孩子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.val &lt;= root.left.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; root.val &gt;= root.right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> isValidBST(root.left) &amp;&amp; isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样写是有问题的，BST 的每个节点应该要小于右边子树的所有节点。但是，这算法会出现根节点的右孩子节点的左孩子节点小于根节点的情况，这不符合二叉搜索树的定义，但是该算法会把它判定为合法的 BST。</p>
<p>出问题的原因在于，<strong>对于每一个节点 root，代码检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，root 的整个左子树都要小于 <code>root.val</code> ，整个右子树都要大于 <code>root.val</code></strong> 。</p>
<p>对于某一个节点 root，他只能管得了自己的左右子节点，怎么把 root 的约束传递给左右子树。</p>
<p>通过<strong>使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line">	<span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span></span><br><span class="line">	<span class="keyword">return</span> isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、在-BST-中搜索一个数"><a href="#二、在-BST-中搜索一个数" class="headerlink" title="二、在 BST 中搜索一个数"></a>二、在 BST 中搜索一个数</h3><p>如果是在二叉树中寻找元素，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (root.val == taget) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="comment">// 当前节点没有找到，就递归的去左右子树中寻找</span></span><br><span class="line">	<span class="keyword">return</span> isInBST(root.left, target) || isInBST(root.right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码相当于穷举了所有节点，适用于所有普通二叉树，但是如何充分利用 BST 左大右小的特性。</p>
<p>不需要递归的搜索两边，类似二分查找思想，根据 <code>target</code> 和 <code>root.val</code> 的大小比较，就能排除一边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (root.val == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (root.val &gt; target) <span class="keyword">return</span> isInBST(root.left, target);</span><br><span class="line">	<span class="keyword">if</span> (root.val &lt; target) <span class="keyword">return</span> isInBST(root.right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对原始框架进行改造，抽象出一套<strong>针对 BST 的遍历框架</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span> <span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root.val == target) <span class="comment">// 找到目标后 do something</span></span><br><span class="line">	<span class="keyword">if</span> (root.val &gt; target) BST(root.left, target);</span><br><span class="line">	<span class="keyword">if</span> (root.val &lt; target) BST(root.right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、在-BST-中插入一个数"><a href="#三、在-BST-中插入一个数" class="headerlink" title="三、在 BST 中插入一个数"></a>三、在 BST 中插入一个数</h3><p>对数据结构的操作无非遍历 + 访问，遍历就是找，访问就是改。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。</p>
<p><strong>一旦涉及改，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 找到空位置插入新节点</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">	<span class="keyword">if</span> (root.val &lt; val) </span><br><span class="line">		root.right = insertIntoBST(root.right, val);</span><br><span class="line">	<span class="keyword">if</span> (root.val &gt; val)</span><br><span class="line">		root.left = insertIntoBST(root.left, val);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、在-BST-中删除一个数"><a href="#四、在-BST-中删除一个数" class="headerlink" title="四、在 BST 中删除一个数"></a>四、在 BST 中删除一个数</h3><p>这个问题稍微服务，跟插入操作类似，先找再改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">		<span class="comment">// 找到，进行删除操作</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">		<span class="comment">// 去左子树中进行查找</span></span><br><span class="line">		root.left = deleteNode(root.left, key);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">		<span class="comment">// 去右子树中进行查找</span></span><br><span class="line">		root.right = deleteNode(root.right, key);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到目标节点后，如何删除这个节点是个难点。因为删除节点的同时，不能破坏 BST 的性质。</p>
<p>比如，有三种情况：</p>
<ul>
<li><p><strong>情况一</strong>：A 恰好是末端节点，两个子节点均为空，那么可以直接删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>情况二</strong>：A 只有一个非空子节点，那么他要让这个孩子接替自己的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line"><span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>情况三</strong>：A 有两个子节点，这就比较复杂了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点或右子树中最小的节点来接替自己</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">	TreeNode minNode = getMin(root.right);</span><br><span class="line">	<span class="comment">// 将 root 改成 minNode</span></span><br><span class="line">	root.val = minNode.val;</span><br><span class="line">	<span class="comment">// 删除 minNode</span></span><br><span class="line">	root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>整合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">		<span class="comment">// 这两个 if 将情况1和情况2都正确处理了</span></span><br><span class="line">		<span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">		<span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">		<span class="comment">// 处理情况3</span></span><br><span class="line">		TreeNode minNode = getMin(root.right);</span><br><span class="line">		root.val = minNode.val;</span><br><span class="line">		root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">		root.left = deleteNode(root.left, key);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">		root.right = deleteNode(root.right, key);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">getMin</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">    <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除操作就完成了。当然，这个删除操作并不完美，因为我们一般不会通过 <code>root.val = minNode.val</code> 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 <code>root</code> 和 <code>minNode</code> 两个节点。</p>
<p>因为具体应用中，val 域可能会是一个复杂的数据结构，修改起来非常麻烦；而链表操作无非改一改指针，不会去碰内部数据。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结以下几个技巧：</p>
<ol>
<li><p>如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p>
</li>
<li><p>在二叉树递归框架之上，扩展出一套 BST 代码框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root.val == target) <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">	<span class="keyword">if</span> (root.val &lt; target) BST(root.right, target);</span><br><span class="line">	<span class="keyword">if</span> (root.val &gt; target) BST(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据代码框架掌握了 BST 的增删改查操作。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/二叉搜素树题目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/二叉搜素树题目/" itemprop="url">二叉搜索树题目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二叉搜索树题目"><a href="#二叉搜索树题目" class="headerlink" title="二叉搜索树题目"></a>二叉搜索树题目</h2><h4 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h4><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
<p><strong>思路1：</strong>可以先进行遍历，得到一个数组序列，找出错误的位置，再重新遍历二叉树进行恢复。空间复杂度为 <code>O(N)</code></p>
<p><strong>思路2：</strong>利用一个前序指针和当前节点进行比较，用 x 保存第一次出错的位置，y 更新迭代最后出错的位置，遍历完成后，将错误的两个位置的值进行互换。比思路1节省空间复杂度。空间复杂度为 <code>O(1)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> recoverTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre;</span><br><span class="line">    <span class="keyword">let</span> x, y;</span><br><span class="line">    <span class="keyword">const</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        reverse(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre &amp;&amp; pre.val &gt; root.val) &#123;</span><br><span class="line">            y = root;</span><br><span class="line">            <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">                x = pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        reverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(root);</span><br><span class="line">    <span class="keyword">const</span> temp = x.val;</span><br><span class="line">    x.val = y.val;</span><br><span class="line">    y.val = temp;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/二叉树基本操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/二叉树基本操作/" itemprop="url">二叉树基本操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h2><h3 id="完全二叉树的一些公式"><a href="#完全二叉树的一些公式" class="headerlink" title="完全二叉树的一些公式"></a>完全二叉树的一些公式</h3><ol>
<li>第 n 层的节点数最多为 <code>2^n</code>个节点</li>
<li>n 层二叉树最多有 <code>2^0 + ... + 2^n = 2^n+1 - 1</code> 个节点</li>
<li>最后一个非叶子节点 length/2</li>
<li>一个节点的孩子节点：2n、2n+1</li>
</ol>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>插入、遍历、深度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node.prototype = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree.prototype = &#123;</span><br><span class="line">    insert: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="keyword">new</span> Node(data, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.root) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = node;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">var</span> parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; parent.data) &#123;</span><br><span class="line">                current = current.left;</span><br><span class="line">                <span class="keyword">if</span> (!current) &#123;</span><br><span class="line">                    parent.left = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.right;</span><br><span class="line">                <span class="keyword">if</span> (!current) &#123;</span><br><span class="line">                    parent.right = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    preOrder: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node) &#123;</span><br><span class="line">            node.show();</span><br><span class="line">            preOrder(node.left);</span><br><span class="line">            preOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    middleOrder: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            middleOrder(node.left);</span><br><span class="line">            node.show();</span><br><span class="line">            middleOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    postOrder: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            postOrder(node.left);</span><br><span class="line">            postOrder(node.right);</span><br><span class="line">            node.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    getMin: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!current.left) &#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    getMax: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!current.right) &#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    getDeep: <span class="function"><span class="keyword">function</span>(<span class="params">node, deep</span>) </span>&#123;</span><br><span class="line">        deep = deep || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> deep;</span><br><span class="line">        &#125;</span><br><span class="line">        deep++;</span><br><span class="line">        <span class="keyword">var</span> dleft = <span class="keyword">this</span>.getDeep(node.left, deep);</span><br><span class="line">        <span class="keyword">var</span> dright = <span class="keyword">this</span>.getDeep(node.right, deep);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(dleft, dright);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Tree();</span><br><span class="line">t.insert(<span class="number">3</span>);</span><br><span class="line">t.insert(<span class="number">8</span>);</span><br><span class="line">t.insert(<span class="number">1</span>);</span><br><span class="line">t.insert(<span class="number">2</span>);</span><br><span class="line">t.insert(<span class="number">5</span>);</span><br><span class="line">t.insert(<span class="number">7</span>);</span><br><span class="line">t.insert(<span class="number">6</span>);</span><br><span class="line">t.insert(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(t);</span><br><span class="line"><span class="built_in">console</span>.log(t.getMin(), t.getMax());</span><br><span class="line"><span class="built_in">console</span>.log(t.getDeep(t.root, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(t.getNode(<span class="number">5</span>, t.root));</span><br></pre></td></tr></table></figure>

<h3 id="树查找"><a href="#树查找" class="headerlink" title="树查找"></a>树查找</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getNode: <span class="function"><span class="keyword">function</span>(<span class="params">data, node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data === node.data) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; node.data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.getNode(data, node.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; node.data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.getNode(data, node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找的条件是必须是有序的线性表</p>
<p>和线性表的中点值进行比较，如果小就继续在小的序列中查找，如此递归直到找到相同的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">data, arr,start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((end + start)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (data == arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(data, arr, start, mid<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(data, arr, mid+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/二叉树-概览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/二叉树-概览/" itemprop="url">二叉树概览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二叉树系列"><a href="#二叉树系列" class="headerlink" title="二叉树系列"></a>二叉树系列</h2><p>树是用来模拟具有树状结构性质的数据集合。根据性质可分为很多种类，只要了解二叉树这种结构就足够了，它是树中最简单、应用最广泛的种类。</p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>重点中的重点，同时掌握递归和非递归版本。递归版本很容易，但真正考验基本功的是非递归版本</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<p>递归遍历框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序遍历代码</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序遍历代码</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="前序遍历代码"><a href="#前序遍历代码" class="headerlink" title="前序遍历代码"></a>前序遍历代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preorderTraversal = <span class="function">(<span class="params">root, array=[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> array;</span><br><span class="line">    array.push(root.val);</span><br><span class="line">    preorderTraversal(root.left);</span><br><span class="line">    preorderTraversal(root.right);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归实现：</p>
<ul>
<li><p>取根节点为目标节点，开始遍历</p>
</li>
<li><p>访问目标节点</p>
</li>
<li><p>左孩子入栈，直至左孩子为空的节点</p>
</li>
<li><p>节点出栈，以右孩子为目标节点，再次执行2，3，4</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preorderTraversal = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> current = root;</span><br><span class="line">    <span class="keyword">while</span>(current || stack.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            result.push(current.val);</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="中序遍历代码"><a href="#中序遍历代码" class="headerlink" title="中序遍历代码"></a>中序遍历代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderTraversal = (root, array=[]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        inorderTraversal(root.left, array);</span><br><span class="line">        array.push(root.val);</span><br><span class="line">        inorderTraversal(root.right, array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归实现：</p>
<ul>
<li><p>取根节点为目标节点，开始遍历</p>
</li>
<li><p>左孩子入栈，直至左孩子为空</p>
</li>
<li><p>节点出栈，访问该节点</p>
</li>
<li><p>以右孩子为目标节点，再次执行 2，3，4</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderTraversal = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> current = root;</span><br><span class="line">    <span class="keyword">while</span>(current || stack.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        result.push(current.val);</span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="后序遍历代码"><a href="#后序遍历代码" class="headerlink" title="后序遍历代码"></a>后序遍历代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postorderTraversal = (root, array=[]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        postorderTraversal(root.left, array);</span><br><span class="line">        postorderTraversal(root.right, array);</span><br><span class="line">        array.push(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归遍历：</p>
<ul>
<li><p>以根节点为目标节点，开始遍历</p>
</li>
<li><p>左孩子入栈，直至左孩子为空的节点</p>
</li>
<li><p>栈顶节点的右孩子为空或被访问过，则节点出栈并访问，将节点标记为已访问</p>
</li>
<li><p>栈节点的右孩子不为空且未被访问，以右孩子为目标节点再执行2，3，4</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postorderTraversal = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> last = <span class="literal">null</span>; <span class="comment">// 标记上一个访问的节点</span></span><br><span class="line">    <span class="keyword">let</span> current = root;</span><br><span class="line">    <span class="keyword">while</span>(current || stack.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = stack[stack.length<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!current.right || current.right == last) &#123;</span><br><span class="line">            current = stack.pop();</span><br><span class="line">            result.push(current.val);</span><br><span class="line">            last = current;</span><br><span class="line">            current = <span class="literal">null</span>; <span class="comment">// 继续弹栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>给一个二叉树，返回其按 <strong>层序遍历</strong> 得到的节点值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leverOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentLevelLength = queue.length;</span><br><span class="line">        <span class="keyword">const</span> level = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;currentLevelLength; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = q.shift();</span><br><span class="line">            level.push(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left) queue.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right) queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(level.slice())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> q = [];</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (q.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentLevelSize = q.length;</span><br><span class="line">        ret.push([]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = q.shift();</span><br><span class="line">            ret[ret.length - <span class="number">1</span>].push(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left) q.push(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right) q.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4><p>根据前序遍历和中序遍历或者中序遍历和后序遍历的特点重建二叉树</p>
<p><strong>思路：</strong></p>
<ul>
<li>前序遍历：根节点 + 左子树前序遍历 + 右子树前序遍历</li>
<li>中序遍历： 左子树中序遍历 + 根节点 + 右子树中序遍历</li>
<li>后序遍历：左子树后序遍历 + 右子树后序遍历 + 根节点</li>
</ul>
<p>根据以上规律，通过前序遍历和中序遍历构造二叉树：</p>
<ul>
<li>前序遍历找到根节点 root</li>
<li>找到 root 在中序遍历中的位置，从而得到左子树和右子树长度</li>
<li>截取左子树的中序遍历、右子树的中序遍历</li>
<li>截取左子树的前序遍历、右子树的前序遍历</li>
<li>递归重建二叉树</li>
</ul>
<p>根据前序和中序构建二叉树</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildBinaryTree = <span class="function">(<span class="params">pre, vin</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pre === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (pre === <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> index;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;vin.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[<span class="number">0</span>] === vin[i]) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> pre_left = pre.slice(<span class="number">1</span>, index+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> pre_right = pre.slice(index+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> in_left = vin.slice(<span class="number">0</span>, index);</span><br><span class="line">    <span class="keyword">const</span> in_right = vin.slice(index+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    node.left = buildBinaryTree(pre_left, in_left);</span><br><span class="line">    node.right = buildBinaryTree(pre_right, in_right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的对称性"><a href="#二叉树的对称性" class="headerlink" title="二叉树的对称性"></a>二叉树的对称性</h3><h4 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h4><p>实现一个函数判断二叉树是不是对称的。</p>
<p>借助辅助函数，将根结点传递</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSymmetrical = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetricalTree(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isSymmetricalTree = <span class="function">(<span class="params">node1, node2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node1 &amp;&amp; !node2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!node1 || !node2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node1.val != node2.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSymmetricalTree(node1.left, node2.right) &amp;&amp; isSymmetricalTree(node1.right, node2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树镜像"><a href="#二叉树镜像" class="headerlink" title="二叉树镜像"></a>二叉树镜像</h4><p>操作给定的二叉树，将其变换为源二叉树的镜像</p>
<p>递归交换所有节点左右节点的位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mirror = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirror(root.left);</span><br><span class="line">        mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树是特殊的二叉树，考察二叉搜索树的题目一般都是考察二叉搜索树的特性。</p>
<ul>
<li>任意节点的左子树不为空，则它的左子树上所有的结点的值均小于它的根结点的值。</li>
<li>任意节点的右子树不为空，则它的右子树上所有的结点的值均大于它的根节点的值。</li>
<li>任意结点的左右子树也是一颗二叉搜索树。</li>
</ul>
<p>二叉搜索树的中序遍历是一个排序后的结点</p>
<h4 id="二叉搜索树的第-k-个结点"><a href="#二叉搜索树的第-k-个结点" class="headerlink" title="二叉搜索树的第 k 个结点"></a>二叉搜索树的第 k 个结点</h4><p>给定一颗二叉搜索树，请找出其中第 k 小的结点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">const</span> kthNode = <span class="function">(<span class="params">root, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    kthNode(root.left, k);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count === k) &#123;</span><br><span class="line">        result = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    kthNode(root.right, k);</span><br><span class="line">    <span class="keyword">return</span> resultl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>二叉树的深度为根节点到最远叶子结点的最长路径上的结点数。</p>
<p><strong>平衡二叉树：左右子树深度之差大于1</strong></p>
<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p>最大深度就是从根节点到最远叶子结点的最长路径上的结点数量。</p>
<p>思路：深度优先遍历 + 分治；<strong>一颗二叉树的最大深度等于左子树深度和右子树深度最大值 + 1</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeDepth = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(treeDepth(root.left), treeDepth(root.right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h4><p>最小深度是从根节点到最近叶子节点的最短路径上的节点</p>
<p>思路：</p>
<ul>
<li>左右子树都不为空：左子树深度和右子树最小深度的最小值 + 1</li>
<li>左树为空：右子树最小深度的最小值 + 1</li>
<li>右树为空：左子树最小深度的最小值 + 1</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> minDepth = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root.left) <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);</span><br><span class="line">    <span class="keyword">if</span> (!root.right) <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(minDepth(root.left), minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>输入一颗二叉树，判断该二叉树是否是平衡二叉树</p>
<p><strong>平衡二叉树的每个子树的深度之差不超过1</strong></p>
<p>思路：</p>
<p>后序遍历二叉树，在遍历二叉树每个节点前都会遍历其左右子树。比较左右子树的深度，若差值大于1则返回一个标记 -1，表示当前子树不平衡。</p>
<p>左右子树有一个不是平衡的，或左右子树差值大于1，则整棵树不平衡</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBalanced = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.abs(height(root.left) - height(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> height = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        reutrn <span class="built_in">Math</span>.max(height(root.left), height(root.right)) +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值得和为输入整数的所有路径。路径定义为从树的根节点开始往下一直到叶节点所经过的结点形成一条路径。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>套用回溯算法的思路</p>
<p>设定一个结果数组 result 来存储所有符合条件的路径</p>
<p>设定一个栈 stack 来存储当前路径中的结点</p>
<p>设定一个和 sum 来标识当前路径之和</p>
<ul>
<li>从根节点开始深度优先遍历，每经过一个节点，将节点入栈</li>
<li>到达叶子节点，且当前路径的和等于目标值，则找到一个可行的解决方案，将其加入到结果数组中</li>
<li>遍历到二叉树的某个节点时有 2 个可能的选项，选择前往左子树或右子树</li>
<li>若存在左子树，继续向左子树递归</li>
<li>若存在右子树，继续向右子树递归</li>
<li>若上述条件均不满足，或已经遍历过，将当前节点出栈，向上回溯</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindPath</span>(<span class="params">root, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        FindPathCore(root, data, [], <span class="number">0</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindPathCore</span>(<span class="params">node, data, stack, sum, result</span>) </span>&#123;</span><br><span class="line">    stack.push(node.val);</span><br><span class="line">    sum += node.val;</span><br><span class="line">    <span class="keyword">if</span>(!node.left &amp;&amp; !node.right &amp;&amp; sum === data) &#123;</span><br><span class="line">        result.push(stack.slice());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.left) &#123;</span><br><span class="line">        FindPathCore(node.left, data, stack, sum, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right) &#123;</span><br><span class="line">        FindPathCore(node.right, data, stack, sum, result);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>二叉搜索树的中序遍历即排序后的序列</p>
<ul>
<li>递归左子树，找到左子树的最后一个节点，根节点左侧连接到左子树的最后一个节点。</li>
<li>当前节点变为已经转换完成的链表的最后一个节点</li>
<li>递归右子树，找到当前树的最后一个节点</li>
<li>回溯到上一层，进行链接</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Convert</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ConvertCore(root);</span><br><span class="line">    <span class="keyword">while</span>(root.left) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConvertCore</span>(<span class="params">node, last</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">        last = ConvertCore(node.left, last);</span><br><span class="line">    &#125;</span><br><span class="line">    node.left = last;</span><br><span class="line">    <span class="keyword">if</span> (last) &#123;</span><br><span class="line">        last.right = node;</span><br><span class="line">    &#125;</span><br><span class="line">    last = node;</span><br><span class="line">    <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">        last = ConvertCore(node.right, last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node head, pre;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = root;</span><br><span class="line">            pre = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre.right = root;</span><br><span class="line">            root.left = pre;</span><br><span class="line">            pre = root;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><p>实现两个函数，分别实现序列化和反序列化二叉树</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul>
<li>若一棵二叉树是不完全的，至少需要两个遍历才能将其重建。但是这种方式有一定的局限性，比如二叉树中不能出现重复节点。</li>
<li>如果二叉树是一棵完全二叉树，只需要知道前序遍历即可将它重建</li>
<li>在序列化二叉树时，可以将空节点使用特殊符号存储起来，这样就可以模拟一棵完全二叉树的前序遍历</li>
<li>在重建二叉树时，当遇到特殊符号当空节点进行处理</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Serialize</span>(<span class="params">root, arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        arr.push(<span class="string">'#'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         arr.push(root.val);</span><br><span class="line">         Serialize(root.left);</span><br><span class="line">         Serialize(root.right);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">','</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deserialize</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deserialize(s.split(<span class="string">','</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deserialize</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> current = arr.shift();</span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="string">'#'</span>) &#123;</span><br><span class="line">        node = &#123; <span class="attr">val</span>: current &#125;;</span><br><span class="line">        node.left = deserialize(arr);</span><br><span class="line">        node.right = deserialize(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h3><p>给定一个二叉树和其中的一个结点，找出中序遍历的下一个结点并返回。注意，树中的结点不仅包含左右子节点，同时包含指向父节点的指针。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul>
<li>右节点不为空：去右节点的最左侧节点</li>
<li>右节点为空：如果节点是父节点的左节点，取父节点</li>
<li>右节点为空：如果节点是父节点的右节点，父节点已经被遍历过，再往上层寻找…</li>
<li>左节点一定在当前节点之前被遍历过</li>
</ul>
<p>如下图的二叉树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   E</span><br><span class="line"> / \   \</span><br><span class="line">C   D   F</span><br></pre></td></tr></table></figure>

<p>中序遍历：<code>CBEDAEF</code></p>
<ul>
<li>B：右节点不为空，下一个节点为右节点 D</li>
<li>C：右节点为空，C 是父节点的左节点，取父节点 B</li>
<li>D：右节点为空，D 是父节点的右节点，再往上层分析，B 是其父节点的左节点，取 B 的父节点 A</li>
<li>F：右节点为空，F 是父节点的右节点，没有符合条件的节点，F 为遍历的最后一个节点，返回 null</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">root, node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    getNext(root.left);</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == node.val) &#123;</span><br><span class="line">        flag = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    getNext(root.right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">        root = root.right;</span><br><span class="line">        <span class="keyword">while</span>(root.left) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!root.next) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root == root.next.left) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.next;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><p>输入两棵二叉树 A、B，判断 B 是不是 A 的子结构（空树不是任意一个树的子结构）</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>首先找到 A 树中和 B 树根节点相同的节点。从此节点开始，从此节点开始递归 AB 树比较是否有不同节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HasSubtree</span>(<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 &amp;&amp; root2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1.val === root2.val) &#123;</span><br><span class="line">            result = compare(root1, root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            result = HasSubtree(root1.left, root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            result = HasSubtree(root1.right, root2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root2 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1.val !== root2.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compare(root1.left, root2.left) &amp;&amp; compare(root1.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树中寻找两个节点的最近公共祖先节点"><a href="#二叉树中寻找两个节点的最近公共祖先节点" class="headerlink" title="二叉树中寻找两个节点的最近公共祖先节点"></a>二叉树中寻找两个节点的最近公共祖先节点</h3><p>利用递归来做</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lowestCommonAncestor = (root, v1, v2) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || root.val ==== v1 || root.val === v2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> left = lowestCommonAncestor(root.left, v1, v2);</span><br><span class="line">    <span class="keyword">const</span> right = lowestCommonAncestor(root.right, v1, v2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!left) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!right) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://uploadfiles.nowcoder.com/files/20201028/2659167_1603849216965_77299a6a0651c7942af18b564e9edc04.png" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/first.jpg" alt="朱程程">
            
              <p class="site-author-name" itemprop="name">朱程程</p>
              <p class="site-description motion-element" itemprop="description">人生当苦无妨，良人当归即好</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/devil-chengcheng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱程程</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
