<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小二、上酒</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-04-05T14:33:06.833Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>朱程程</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BFS框架套路</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/BFS%E6%A1%86%E6%9E%B6%E5%A5%97%E8%B7%AF/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/BFS%E6%A1%86%E6%9E%B6%E5%A5%97%E8%B7%AF/</id>
    <published>2022-04-05T14:23:39.261Z</published>
    <updated>2022-04-05T14:33:06.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFS框架套路"><a href="#BFS框架套路" class="headerlink" title="BFS框架套路"></a>BFS框架套路</h2><ul><li>DFS：深度优先遍历</li><li>BFS：广度优先遍历</li></ul><p>DFS 深度优先遍历其实就是回溯算法。而 BFS 的核心思想就是将一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，BFS 算法一般都是使用队列这种数据结构，每次将一个节点周围的所有节点加入队列。</p><p>BFS 相对于 DFS 的最主要区别是：<strong>BFS 找到的路径一定是最短的，但是代价就是空间复杂度比DFS大很多</strong></p><h3 id="一、算法框架"><a href="#一、算法框架" class="headerlink" title="一、算法框架"></a>一、算法框架</h3><p>BFS 出现的常见场景。问题的<strong>本质就是在一幅图中找到起点 <code>start</code> 到终点 <code>target</code> 的最近距离</strong></p><p>这种广义描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？</p><p>再比如两个单词，要求通过某些替换，将其中一个变成另一个，每次只能替换一个字符，最少要替换几次。</p><p>这些问题的本质就是一幅图，从一个起点，走到终点，问最短路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点start到终点target的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/*将当前队列中的所有节点向四周扩散*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/*重点：判断是否到达终点*/</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/*将cur的相邻节点加入队列*/</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*重点：更新步数在这里*/</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列是 BFS 的核心数据结构； <code>cur.adj()</code> 泛指 <code>cur</code> 相邻的节点，比如说二维数组中， <code>cur</code>上下左右四面位置就是相邻节点，<code>visited</code>的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要<code>visited</code></p><p>JS 框架：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bfs = (start, target) &#123;</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="keyword">const</span> visited = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    queue.push(start);</span><br><span class="line">    visited[start] = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> len = queue.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">            <span class="keyword">if</span> (node === target) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="keyword">for</span> (Node x : x.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not visited) &#123;</span><br><span class="line">                    queue.push(x);</span><br><span class="line">                visited[x] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最小高度"><a href="#二叉树的最小高度" class="headerlink" title="二叉树的最小高度"></a>二叉树的最小高度</h3><p>判断一棵二叉树的最小高度</p><p>怎么套到 BFS 框架中，首先明确一下起点 <code>start</code> 和 <code>target</code> 是什么，如何判断到达了终点。</p><p><strong>显然起点就是root根节点，终点就是靠近根节点的那个叶子节点</strong>，叶子节点就是两个子节点都是 null 的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 到达叶子节点</span></span><br></pre></td></tr></table></figure><p>按照上面的框架稍加改造写解法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = q.size();</span><br><span class="line">        <span class="comment">/*当前队列中的节点向四周扩散*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            <span class="comment">// 判断是否到达终点</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> depth;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minDepth</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> len = queue.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> cur = queue.shift();</span><br><span class="line">            <span class="keyword">if</span> (!cur.left &amp;&amp; !cur.right) <span class="keyword">return</span> depth;</span><br><span class="line">            <span class="keyword">if</span> (cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right) queue.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    retrurn depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树是很简单的数据结构，其实其它复杂问题都是这个框架的变形。在讨论复杂问题之前，解答两个问题:</p><p><strong>1. 为什么BFS可以找到最短路径，而DFS不行</strong></p><p>首先，BFS 的逻辑，<code>depth</code>每增加一次，队列中的所有结点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。</p><p>DFS 其实也可以找最短路径，但是时间复杂度相对高很多。DFS 实际上靠递归的堆栈记录走过的路径，要找到最短路径，得将二叉树中所有树枝都探索完才能对比出最短的路径。而 DFS可以在不遍历完整棵树的条件下找到最短距离的。</p><p><strong>2. 既然BFS这么好，为什么还要DFS存在</strong></p><p>BFS可以找到最短距离，但是空间复杂度高，而DFS的空间复杂度较低。</p><p>假设二叉树是满二叉树，节点数为<code>N</code>，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏的情况下顶多就是树的高度，也就是<code>O(logN)</code></p><p>但是如果是 BFS 算法，队列中每次都会存储着二叉树一层的结点，这种情况下最坏的空间复杂度是树的最底层节点的数量，也就是 <code>N/2</code>.</p><p>所以，BFS还是有代价的。一般来说在找最短路径的时候使用 BFS，其它时候还是 DFS 使用的多一些（主要递归代码好写）</p><h3 id="解开密码锁的最少次数"><a href="#解开密码锁的最少次数" class="headerlink" title="解开密码锁的最少次数"></a>解开密码锁的最少次数</h3><p>有一个有四个拨轮的转盘锁，每个拨轮有10个数字：0-9。每个拨轮可自由旋转。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 <code>0000</code>，一个代表四个拨轮的数字的字符串。</p><p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁就会被永久锁定，无法再被旋转。</p><p>字符串 <code>target</code> 代表可以解锁的数字，需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1</p><p>题目描述的就是生活中常见的密码锁，若没有任何约束，最少的拨动次数很好算，就像平时开密码锁那样直奔密码拨就行。</p><p>但现在的难点在于，不能出现 <code>deadends</code> ，应该如何计算出最少的转动次数呢</p><p><strong>首先，不管所有的限制条件，不管 <code>deadends</code> 和 <code>target</code>的限制，就思考一个问题：如果设计一个算法，穷举所有的密码组合，如何做</strong></p><p>就穷举，再简单一点，如果只转一下锁，有几种可能。总共有四个位置，每个位置可以向上、下两个方向转，也就是 8 种可能。</p><p><strong>这可以抽象成一幅图，每个节点有 8 个相邻的节点</strong>，又是求最短距离，典型的 BFS。</p><p>可以先写一个简陋的 BFS 框架代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 s[j] 向上拨动一次</span></span><br><span class="line"><span class="function">String <span class="title">plusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(ch[j] == <span class="string">'9'</span>)</span><br><span class="line">        ch[j] = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ch[j] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 s[i] 向下拨动一次</span></span><br><span class="line"><span class="function">String <span class="title">minusOne</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(ch[i] == <span class="string">'0'</span>)</span><br><span class="line">        ch[i] = <span class="string">'9'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ch[i] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 框架，打印出所有可能的密码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(<span class="string">"0000"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line">            <span class="comment">/*判断是否到达终点*/</span></span><br><span class="line">            <span class="keyword">if</span> (cur.equals(target))</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*将一个节点的相邻节点加入队列*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                q.offer(up);</span><br><span class="line">                q.offer(down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*这里增加步数*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码已经能够穷举所有可能的密码组合了，但是显然不能完成题目，有如下问题需要解决：</strong></p><ol><li>会走回头路。比如从 <code>0000</code>拨到 <code>1000</code> ，但是等从队列拿出 <code>1000</code> 时，还会拨出一个 <code>0000</code>，这样的话会产生死循环。</li><li>没有终止条件，按照题目要求，找到 <code>target</code> 就结束并返回拨动的次数。</li><li>没有对 <code>deadends</code> 的处理，按道理这些死亡密码是不能出现的，即遇到这些密码的时候需要跳过。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录需要跳过的死亡密码</span></span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : deadends) deads.add(s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录已经穷举过的密码，防止走回头路</span></span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 从起点开始启动广度优先搜索</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q.offer(<span class="string">"0000"</span>);</span><br><span class="line">    visited.add(<span class="string">"0000"</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = q.size();</span><br><span class="line">        <span class="comment">/*将当前队列的所有节点向周围扩散*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*判断是否到达终点*/</span></span><br><span class="line">            <span class="keyword">if</span> (deads.contains(cur))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.equals(target))</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*将一个节点的未遍历相邻节点加入队列*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(up)) &#123;</span><br><span class="line">                    q.offer(up);</span><br><span class="line">                    visited.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(down)) &#123;</span><br><span class="line">                    q.offer(down);</span><br><span class="line">                    visited.add(down);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果穷举完都没找到目标密码，那就是找不到了。</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，这道题目就解决了。有一个比较小的优化：可以不需要 <code>dead</code> 这个哈希集合，可以直接将这些元素初始化到 <code>visited</code>集合中，效果是一样的。</p><h3 id="双向-BFS-优化"><a href="#双向-BFS-优化" class="headerlink" title="双向 BFS 优化"></a>双向 BFS 优化</h3><p>BFS 算法还有一种稍微高级一点的优化思路：<strong>双向BFS</strong>，可以进一步提高算法效率。</p><p>区别：<strong>传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止</strong>。</p><p>如果终点在最底部，按照传统 BFS 算法的策略，会把整棵树的节点都搜索一遍，最后找到 <code>target</code>;而双向 BFS 其实只遍历了半棵树就出现了交集，也就是找到了最短距离。</p><p><strong>不过，双向 BFS 也有局限，因为必须知道终点在哪里</strong>。比如二叉树最小高度的问题，一开始根本就不知道终点在哪里，也就无法使用双向 BFS ，但是第二个密码锁问题是可以使用双向 BFS 算法来提高效率的。代码稍加修改即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : deadends) deads.add(s);</span><br><span class="line">    <span class="comment">// 用集合不用队列可快速判断元素是否存在</span></span><br><span class="line">    Set&lt;String&gt; q1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; q2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q1.add(<span class="string">"0000"</span>);</span><br><span class="line">    q2.add(target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q1.isEmpty() &amp;&amp; !q2.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果</span></span><br><span class="line">        Set&lt;String&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将q1中的所有结点向周围扩散</span></span><br><span class="line">        <span class="keyword">for</span> (String cur:q1) &#123;</span><br><span class="line">            <span class="comment">// 判断是否到达终点</span></span><br><span class="line">            <span class="keyword">if</span> (deads.contains(cur))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (q2.contains(cur))</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            visited.add(cur);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将一个结点的未遍历相邻结点加入集合</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(up))</span><br><span class="line">                    temp.add(up);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(down))</span><br><span class="line">                    temp.add(down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">        <span class="comment">// temp相当于 q1</span></span><br><span class="line">        <span class="comment">// 这里交换 q1,q2, 下一轮 while 就是扩散 q2</span></span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向 BFS 还是遵循 BFS 算法框架的，只是<strong>不再使用队列，而是使用 <code>HashSet</code> 方便快速判断两个集合是否有交集</strong>。</p><p>另外一个技巧就是 <strong>while 循环的最后交换 <code>q1</code> 和 <code>q2</code> 的内容</strong>，所以只要默认扩散 <code>q1</code> 就相当于轮流扩散 <code>q1</code> 和 <code>q2</code>.</p><p><strong>不过，无论传统 BFS 还是双向 BFS，无论做不做优化，时间复杂度都是一样的，</strong>只能说双向 BFS 是一种 trick ，算法运行的速度会相对快一点。双向 BFS 掌握不掌握都无所谓。</p><h3 id="BFS-题目"><a href="#BFS-题目" class="headerlink" title="BFS 题目"></a>BFS 题目</h3><h4 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h4><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><ul><li><p>值 0 代表空单元格；</p></li><li><p>值 1 代表新鲜橘子；</p></li><li><p>值 2 代表腐烂的橘子。</p><p>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p></li></ul><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> orangesRotting = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 新鲜橘子数量</span></span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] === <span class="number">2</span>) &#123;</span><br><span class="line">                queue.push([i, j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> round = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count&gt;<span class="number">0</span> &amp;&amp; queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        round++;</span><br><span class="line">        <span class="keyword">const</span> len = queue.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> temp = queue.shift();</span><br><span class="line">            <span class="keyword">let</span> row = temp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">let</span> col = temp[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (row<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row<span class="number">-1</span>][col] === <span class="number">1</span>) &#123;</span><br><span class="line">                grid[row<span class="number">-1</span>][col] = <span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.push([row<span class="number">-1</span>, col]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (row+<span class="number">1</span> &lt; grid.length &amp;&amp; grid[row+<span class="number">1</span>][col] === <span class="number">1</span>) &#123;</span><br><span class="line">                grid[row+<span class="number">1</span>][col] = <span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.push([row+<span class="number">1</span>, col]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (col<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col<span class="number">-1</span>] === <span class="number">1</span>) &#123;</span><br><span class="line">                grid[row][col<span class="number">-1</span>] = <span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.push([row, col<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (col+<span class="number">1</span> &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[row][col+<span class="number">1</span>] === <span class="number">1</span>) &#123;</span><br><span class="line">                grid[row][col+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.push([row, col+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> round;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h4><p>广度优先遍历BFS， 因为需要输出路径；所以使用一个数组 prev 来记录坐标 (x, y) 的上一个坐标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (line = readline()) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = <span class="built_in">parseInt</span>(line.split(<span class="string">' '</span>)[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> n = <span class="built_in">parseInt</span>(line.split(<span class="string">' '</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> arr = [];</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> prev = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        arr.push(readline().split(<span class="string">' '</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="keyword">const</span> visited = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        visited.push(<span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="literal">false</span>));</span><br><span class="line">        prev.push(<span class="keyword">new</span> <span class="built_in">Array</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue.push([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> len = queue.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = queue.shift();</span><br><span class="line">        <span class="keyword">let</span> row = tmp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> col = tmp[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (row === m - <span class="number">1</span> &amp;&amp; col === n - <span class="number">1</span>) &#123;</span><br><span class="line">          res.unshift([row, col])</span><br><span class="line">          <span class="keyword">while</span> (row !== <span class="number">0</span> || col !== <span class="number">0</span>) &#123;</span><br><span class="line">            res.unshift(prev[row][col])</span><br><span class="line">            <span class="keyword">const</span> tp = prev[row][col];</span><br><span class="line">            [row, col] = tp;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'('</span> + res[i][<span class="number">0</span>] + <span class="string">','</span> + res[i][<span class="number">1</span>] + <span class="string">')'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上</span></span><br><span class="line">        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[row - <span class="number">1</span>][col] &amp;&amp; arr[row - <span class="number">1</span>][col] !== <span class="string">'1'</span>) &#123;</span><br><span class="line">          queue.push([row - <span class="number">1</span>, col]);</span><br><span class="line">          visited[row - <span class="number">1</span>][col] = <span class="literal">true</span>;</span><br><span class="line">          prev[row - <span class="number">1</span>][col] = [row, col];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下</span></span><br><span class="line">        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; m &amp;&amp; !visited[row + <span class="number">1</span>][col] &amp;&amp; arr[row + <span class="number">1</span>][col] !== <span class="string">'1'</span>) &#123;</span><br><span class="line">          queue.push([row + <span class="number">1</span>, col]);</span><br><span class="line">          visited[row + <span class="number">1</span>][col] = <span class="literal">true</span>;</span><br><span class="line">          prev[row + <span class="number">1</span>][col] = [row, col];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向左</span></span><br><span class="line">        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[row][col - <span class="number">1</span>] &amp;&amp; arr[row][col - <span class="number">1</span>] !== <span class="string">'1'</span>) &#123;</span><br><span class="line">          queue.push([row, col - <span class="number">1</span>]);</span><br><span class="line">          visited[row][col - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">          prev[row][col - <span class="number">1</span>] = [row, col];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向右</span></span><br><span class="line">        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; n &amp;&amp; !visited[row][col + <span class="number">1</span>] &amp;&amp; arr[row][col + <span class="number">1</span>] !== <span class="string">'1'</span>) &#123;</span><br><span class="line">          queue.push([row, col + <span class="number">1</span>]);</span><br><span class="line">          visited[row][col + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">          prev[row][col + <span class="number">1</span>] = [row, col];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BFS框架套路&quot;&gt;&lt;a href=&quot;#BFS框架套路&quot; class=&quot;headerlink&quot; title=&quot;BFS框架套路&quot;&gt;&lt;/a&gt;BFS框架套路&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;DFS：深度优先遍历&lt;/li&gt;
&lt;li&gt;BFS：广度优先遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;p</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-04-05T14:23:39.257Z</published>
    <updated>2022-04-05T14:32:48.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串专题"><a href="#字符串专题" class="headerlink" title="字符串专题"></a>字符串专题</h2><ul><li>替换空格</li><li>表示数值的字符串</li><li>字符流中能第一个不重复的字符</li><li>字符串的排列</li><li>字符串翻转</li><li>正则表达式匹配</li></ul><h4 id="1-替换空格"><a href="#1-替换空格" class="headerlink" title="1. 替换空格"></a>1. 替换空格</h4><p>实现一个函数，将字符串中的每个空格替换成 <code>&quot;%20&quot;</code>。例如，当字符串为 <code>We Are Happy</code> ，则经过替换之后的字符串为 <code>We20%Are20%Happy</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/\s/g</span>, <span class="string">'%20'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">Str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">' '</span>).join(<span class="string">'%20'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拓展</strong></p><p>允许出现多个空格，多个空格用一个 <code>%20</code> 替换。（用正则表达式找到连续空格进行替换）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/\s+/g</span>, <span class="string">'%20'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-表示数值的字符串"><a href="#2-表示数值的字符串" class="headerlink" title="2. 表示数值的字符串"></a>2. 表示数值的字符串</h4><p>(leetcode上的编译简直流氓)</p><p>实现一个函数来判断字符串是否表示数值（包括整数和小数）。例如，字符串<code>”+100“，”5e2“, &quot;-123&quot;, &quot;3.1416&quot;</code> 和 <code>”-1E-16“</code> 都表示数值。 但是<code>&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;</code>和<code>&quot;12e+4.3&quot;</code>都不是。</p><p>考虑完全所有情况：</p><ul><li>只能出现数字、符号位、小数点、指数位</li><li>小数点，指数符号只能出现一次，且不能出现在开头结尾</li><li>指数位出现后，小数点不允许再出现</li><li>符号位只能出现在开头和指数位后面</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hasPoint = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> hasExp = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.replace(<span class="regexp">/\s*/</span>, <span class="string">''</span>).length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] &gt;= <span class="number">0</span> &amp;&amp; s[i] &lt;= <span class="number">9</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">'.'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasPoint || hasExp || i === <span class="number">0</span> || i === s.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      hasPoint = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">'e'</span> || s[i] === <span class="string">'E'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasExp || i === <span class="number">0</span> || i === s.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      hasExp = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">'+'</span> || s[i] === <span class="string">'-'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">0</span> || s[i - <span class="number">1</span>] === <span class="string">'e'</span> || s[i - <span class="number">1</span>] === <span class="string">'E'</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>极致的简单解法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="keyword">if</span> (!s.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isNaN</span>(<span class="built_in">Number</span>(s.trim()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-字符流中第一个不重复的字符"><a href="#3-字符流中第一个不重复的字符" class="headerlink" title="3. 字符流中第一个不重复的字符"></a>3. 字符流中第一个不重复的字符</h4><p>实现一个函数用来找字符流中第一个只出现一次的字符。如果当前字符流没有存在出现一次的字符，返回 # 字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> a = s[i];</span><br><span class="line">        map.has(a) ? map.set(a, map.get(a)+<span class="number">1</span>) : map.set(a, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> a = s[i];</span><br><span class="line">        <span class="keyword">if</span> (map.get(a) === <span class="number">1</span>) <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-字符串的排列"><a href="#4-字符串的排列" class="headerlink" title="4. 字符串的排列"></a>4. 字符串的排列</h4><p>输入一个字符串，按字典打印该字符串中字符的所有排列。</p><p>这是回溯问题 + 剪枝。类似之前的全排列问题，只不过这里要更复杂些，这是存在重复字符的可能。</p><p>先假设没有重复字符出现，此时的代码就相当于使用回溯框架：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permutation = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> track = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> backtrack = <span class="function"><span class="keyword">function</span>(<span class="params">s, track</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (track.length === s.length) &#123;</span><br><span class="line">            res.push(track.join(<span class="string">''</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;s.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (track.includes(s[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.push(s[i]);</span><br><span class="line">            backtrack(s, track);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    backtrack(s, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有重复字符的存在，题目还是很简单的，但是如果条件改变，存在重复的字符，那么上面的代码就不适用，而且需要考虑的就多了。</p><ul><li>首先还是可以利用回溯算法的框架，但是不能靠 判断 <code>track</code> 数组来判断剪枝了</li><li>需要两个数组，一个数组对选择进行存储，去除重复的可能；另一个数组用于将之前选过的排除</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permutation = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> track = [];</span><br><span class="line">    <span class="keyword">const</span> visited = &#123;&#125;; <span class="comment">// 相当于之前的的 track 判断是否遍历过的功能</span></span><br><span class="line">    <span class="keyword">const</span> backtrack = <span class="function"><span class="keyword">function</span>(<span class="params">s, track</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (track.length === s.length) &#123;</span><br><span class="line">            res.push(track.join(<span class="string">''</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> inclu = []; <span class="comment">// 保存当前位置确定的元素，放置不重复的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;s.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (inclu.includes(s[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            inclu.push(s[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            track.push(s[i]);</span><br><span class="line">            backtrack(s, track);</span><br><span class="line">            track.pop();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(s, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-字符串翻转"><a href="#5-字符串翻转" class="headerlink" title="5. 字符串翻转"></a>5. 字符串翻转</h4><h5 id="（1）翻转单词顺序"><a href="#（1）翻转单词顺序" class="headerlink" title="（1）翻转单词顺序"></a>（1）翻转单词顺序</h5><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。</p><ul><li>利用 JS 内置函数进行解决</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.trim().split(<span class="regexp">/\s+/g</span>).reverse().join(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-左旋转字符串"><a href="#2-左旋转字符串" class="headerlink" title="(2) 左旋转字符串"></a>(2) 左旋转字符串</h5><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。例如输入字符串 <code>&quot;abcdefg&quot;</code> 和数字 2 ，该函数将返回左旋转 2 位得到的结果 <code>&quot;cdefgab&quot;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="function"><span class="keyword">function</span>(<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=n; i&lt;s.length; i++) &#123;</span><br><span class="line">        res.push(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        res.push(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">''</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以先拼接两个字符串，再截取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="function"><span class="keyword">function</span>(<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &amp;&amp; n!= <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (s + s).substr(n, s.length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-正则表达式匹配"><a href="#6-正则表达式匹配" class="headerlink" title="6. 正则表达式匹配"></a>6. 正则表达式匹配</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符串专题&quot;&gt;&lt;a href=&quot;#字符串专题&quot; class=&quot;headerlink&quot; title=&quot;字符串专题&quot;&gt;&lt;/a&gt;字符串专题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;替换空格&lt;/li&gt;
&lt;li&gt;表示数值的字符串&lt;/li&gt;
&lt;li&gt;字符流中能第一个不重复的字符&lt;/li&gt;
</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2022-04-05T14:23:39.254Z</published>
    <updated>2022-04-05T14:32:37.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>数组中，我们可以通过索引随机访问元素，但是再某些情况下，我们需要限制数据的访问顺序，于是就有两种限制访问顺序的数据结构：栈（先进后出）、队列（先进先出）</p><h4 id="队列和栈的互相实现"><a href="#队列和栈的互相实现" class="headerlink" title="队列和栈的互相实现"></a>队列和栈的互相实现</h4><h5 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h5><p>用两个栈来实现一个队列，完成队列的 push 和 pop 操作。队列中的元素为 int 类型</p><p><strong>思路：</strong>两个栈，栈 1 用于入队列存储；栈 2 用于出队列时将栈 1 的数据依次出栈，并入栈到栈 2 中。栈 2 出栈即栈 1 底部数据即队列要出的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack1 = [];</span><br><span class="line"><span class="keyword">const</span> stack2 = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stack2.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack2.pop() || <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="两个队列实现一个栈"><a href="#两个队列实现一个栈" class="headerlink" title="两个队列实现一个栈"></a>两个队列实现一个栈</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue1 = [];</span><br><span class="line"><span class="keyword">const</span> queue2 = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue1.length === <span class="number">0</span>) &#123;</span><br><span class="line">        queue1.push(x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(queue2.length) &#123;</span><br><span class="line">            queue1.push(queue2.shift())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue2.length === <span class="number">0</span>) &#123;</span><br><span class="line">        queue2.push(X);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(queue1.length) &#123;</span><br><span class="line">            queue2.push(queue1.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue1.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.shift();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue2.shift();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-包含-min-函数的栈"><a href="#2-包含-min-函数的栈" class="headerlink" title="2. 包含 min 函数的栈"></a>2. 包含 min 函数的栈</h4><p>定义栈的数据结构，在该类型中实现以恶搞能够得到栈中所含最小元素的 min 函数</p><p><strong>思路：</strong></p><ul><li>定义两个栈，一个栈用于存储数据，另一个栈用于存储每次数据进栈时栈的最小值。</li><li>每次数据进栈时，将数据和最小值栈的栈顶元素进行比较，将较小的值存入最小值栈中</li><li>数据栈出栈，最小值栈也出栈。这样最小值栈的栈顶永远是当前栈的最小值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataStack = [];</span><br><span class="line"><span class="keyword">const</span> minStack = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    dataStack.push(node);</span><br><span class="line">    <span class="keyword">if</span> (minStack.length === <span class="number">0</span> || node&lt;min()) &#123;</span><br><span class="line">        minStack.push(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        minStack.push(min());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    minStack.pop();</span><br><span class="line">    dataStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">top</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = dataStack.length;</span><br><span class="line">    <span class="keyword">return</span> length&gt;<span class="number">0</span> &amp;&amp; dataStack[length<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = minStack.length;</span><br><span class="line">    <span class="keyword">return</span> length&gt;<span class="number">0</span> &amp;&amp; minStack[length<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-栈的压入、弹出序列"><a href="#3-栈的压入、弹出序列" class="headerlink" title="3. 栈的压入、弹出序列"></a>3. 栈的压入、弹出序列</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 <code>1,2,3,4,5</code> 是某栈的压入顺序，序列 <code>4,5,3,2,1</code>是该压栈序列对应的一个弹出序列，但 <code>4,3,5,1,2</code> 就不可能是该压栈序列的弹出序列。</p><p><strong>思路：</strong></p><ul><li>借助一个辅助栈来模拟压入、弹出的过程</li><li>设置一个索引 <code>idx</code>，记录出栈序列栈顶的位置</li><li>将压入顺序中的数据依次入栈</li><li>当辅助栈栈顶氧元素和压栈顶元素相同时，辅助栈出栈，每次出栈索引 <code>idx + 1</code></li><li>出栈有可能在任意一次入栈后进行，当辅助栈栈顶元素和压栈栈顶元素相同时，继续让 压入序列入</li><li>当所有数据入栈完成，如果出栈顺序正确，那么辅助栈为空</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPopOrder</span>(<span class="params">pushV, popV</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = []; <span class="comment">// 辅助栈</span></span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;pushV.length; i++) &#123;</span><br><span class="line">        stack.push(pushV[i]);</span><br><span class="line">        <span class="keyword">while</span>(stack.length &amp;&amp; stack[stack.length<span class="number">-1</span>] === popV[idx]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-滑动窗口的最大值"><a href="#4-滑动窗口的最大值" class="headerlink" title="4. 滑动窗口的最大值"></a>4. 滑动窗口的最大值</h4><p>给定一个数组 <code>nums</code> ，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。滑动窗口每次只向右移动一位。返回滑动窗口最大值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">window</span> = [];</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">window</span>.length &amp;&amp; nums[i] &gt;= nums[<span class="built_in">window</span>[<span class="built_in">window</span>.length - <span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="built_in">window</span>.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">window</span>.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(nums[<span class="built_in">window</span>[<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=k; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">window</span>.length &amp;&amp; nums[i] &gt;= nums[<span class="built_in">window</span>[<span class="built_in">window</span>.length- <span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="built_in">window</span>.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">window</span>.push(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">window</span>[<span class="number">0</span>] &lt;= i-k) &#123;</span><br><span class="line">            <span class="built_in">window</span>.shift()</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(nums[<span class="built_in">window</span>[<span class="number">0</span>]])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;栈和队列&quot;&gt;&lt;a href=&quot;#栈和队列&quot; class=&quot;headerlink&quot; title=&quot;栈和队列&quot;&gt;&lt;/a&gt;栈和队列&lt;/h2&gt;&lt;p&gt;数组中，我们可以通过索引随机访问元素，但是再某些情况下，我们需要限制数据的访问顺序，于是就有两种限制访问顺序的数据结构：栈（</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>图的逻辑和实现</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%9A%84%E9%80%BB%E8%BE%91%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%9A%84%E9%80%BB%E8%BE%91%E5%92%8C%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-04-05T14:23:39.251Z</published>
    <updated>2022-04-05T14:32:22.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的逻辑和实现"><a href="#图的逻辑和实现" class="headerlink" title="图的逻辑和实现"></a>图的逻辑和实现</h2><p>图可以玩出更多的算法，解决更复杂的问题，但本质上图可以认为是多叉树的延申。</p><p>面试笔试很少出现图相关的问题，就算有，大多也是简单的遍历问题，基本可以完全照搬多叉树的遍历。</p><p>至于最小生成树，Dijkstra，网络流这些算法，学习的成本高，但收益低，没有性价比，不如多刷几道动态规划。</p><p>图是由<strong>节点</strong>和<strong>边</strong>构成的。根据逻辑结构，我们可以认为每个节点的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图节点的逻辑结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">Vertex[] neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现几乎和多叉树节点一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基本的 N 叉树节点*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode[] children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这种实现是逻辑上的，实际上很少用这个 Vertex 类实现图，而是用常说的<strong>邻接表和邻接矩阵</strong>来实现。</p><p><strong>邻接表</strong>很直观，将每个节点 x 的邻居都存到一个列表里，然后将 x 和这个列表关联起来，这样就可以通过一个节点 x 找到它的所有相邻节点。</p><p><strong>邻接矩阵</strong>是一个二维布尔数组 matrix，如果节点 x 和 y 是相连的，就将<code>matrix[x][y]</code>设为 true。</p><p>两种存储图的方式，各有优劣。</p><ul><li>对于邻接表，好处是占用空间少；邻接矩阵需要更多的存储空间，也易造成浪费。</li><li>邻接表是无法快速判断两个节点是否相邻，邻接矩阵可以快速判断，效率高。</li></ul><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历可以参考多叉树，多叉树的遍历框架如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">traverse(child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图和多叉树最大的区别是，图是可能包含环的，你从图的某一个节点开始遍历，可能走一圈又回到这个节点。</p><p>所以，如果图包含闭环，遍历框架就需要一个 visited 数组进行辅助：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 经过节点 s</span></span><br><span class="line">visited[s] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (TreeNode neighbor : graph.neighbors(s))</span><br><span class="line">traverse(neighbor);</span><br><span class="line"><span class="comment">// 离开节点 s</span></span><br><span class="line">visited[s] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 visited 数组的操作很像回溯算法中的“做选择”和”撤销选择“，区别在于位置，回溯算法中的操作是在 for 循环里面，而对 visited 数组的操作在 for 循环外面。唯一的区别就是对根节点的处理。</p><p>比如下面两种多叉树的遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.println(<span class="string">"enter:"</span> + root.val);</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"leave:"</span> + root.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        System.out.println(<span class="string">"enter:"</span> + child.val);</span><br><span class="line">        traverse(child);</span><br><span class="line">        System.out.println(<span class="string">"leave:"</span> + child.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前者会正确打印所有节点的进入和离开信息，后者唯独会少打印整棵树根节点的进入和离开信息。</p><p>回溯算法关注的不是节点，而是树枝，所以回溯算法框架会使用后者。</p><p>对于图的遍历，应该把 visited 的操作放到 for 循环外面，否则会漏掉起始点的遍历。</p><p>当然，<strong>当有向图含有环的时候才需要 visited 数组辅助</strong>，如果不含环，连 visited 数组都省了，基本就是多叉树的遍历。</p><h3 id="题目实践"><a href="#题目实践" class="headerlink" title="题目实践"></a>题目实践</h3><h4 id="所有可能路径"><a href="#所有可能路径" class="headerlink" title="所有可能路径"></a>所有可能路径</h4><p>leetcode 797题</p><p>题目输入一幅有向无环图，这个图包含 n 个节点，标号为 0, 1, 2,…, n-1，计算所有从节点 0 到节点 n-1 的路径。</p><p>输入这个 graph 其实就是 邻接表 表示的一幅图，<code>graph[i]</code>存储这个节点 i 的所有邻居节点。</p><p>比如输入 <code>graph = [[1, 2], [3], [3], []]</code></p><p>算法应该返回 <code>[[0, 1, 3], [0, 2, 3]]</code>，即 0 到 3 的所有路径。</p><p><strong>算法很简单，以 0 为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可</strong></p><p>输入的是有向无环，就不需要 visited 数组辅助</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录所有路径</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    traverse(graph, <span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*图的遍历框架*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> s, LinkedList&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加节点 s 到路径</span></span><br><span class="line">    path.addLast(s);</span><br><span class="line">    <span class="keyword">int</span> n = graph.length;</span><br><span class="line">    <span class="keyword">if</span> (s == n-<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 到达终点</span></span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">        path.removeLast();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归每个相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : graph[s]) &#123;</span><br><span class="line">        traverse(graph, v, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从路径中移除节点s</span></span><br><span class="line">    path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    traverse(graph, <span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> s, List&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">    path.add(s);</span><br><span class="line">    <span class="keyword">if</span> (s == graph.length-<span class="number">1</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归每个相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : graph[s]) &#123;</span><br><span class="line">        traverse(graph, v, path);</span><br><span class="line">    &#125;</span><br><span class="line">    path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图的逻辑和实现&quot;&gt;&lt;a href=&quot;#图的逻辑和实现&quot; class=&quot;headerlink&quot; title=&quot;图的逻辑和实现&quot;&gt;&lt;/a&gt;图的逻辑和实现&lt;/h2&gt;&lt;p&gt;图可以玩出更多的算法，解决更复杂的问题，但本质上图可以认为是多叉树的延申。&lt;/p&gt;
&lt;p&gt;面试笔试很</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>双指针技巧总结</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-05T14:23:39.248Z</published>
    <updated>2022-04-05T14:32:08.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双指针技巧总结"><a href="#双指针技巧总结" class="headerlink" title="双指针技巧总结"></a>双指针技巧总结</h2><p>双指针分为两类，一类是快慢指针，一类是左右指针。前者主要解决链表中的问题，比如典型的判断链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。</p><h3 id="一、快慢指针"><a href="#一、快慢指针" class="headerlink" title="一、快慢指针"></a>一、快慢指针</h3><p>快慢指针一般都初始化指向链表的头结点 <code>head</code>，前进时快指针 <code>fast</code> 在前，慢指针 <code>slow</code> 在后，巧妙解决一些链表中的问题。</p><ul><li>判断链表中是否有环</li><li>假设链表中有环，求环的初始点</li><li>寻找链表的中点</li><li>寻找链表的倒数第 n 个节点</li></ul><h5 id="1-判断链表中是否有环"><a href="#1-判断链表中是否有环" class="headerlink" title="1. 判断链表中是否有环"></a>1. 判断链表中是否有环</h5><p>这属于链表的最基本操作。</p><p>单链表的特点时每个节点只知道下一个节点，所以一个指针无法判断链表中是否有环的。</p><p>如果链表中不含环，那么指针最终会遇到空指针 <code>null</code> 表示链表到头了，这样可以判断该链表不含环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形链表中没有 <code>null</code> 指针作为尾部节点。</p><p>经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含环，跑的快的那个指针最终会遇到 <code>null</code>，说明链表不含环；如果含有环，快指针最终会超满指针一圈，和慢指针相遇，说明链表含有环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-已知链表中含有环，返回这个环的起始位置"><a href="#2-已知链表中含有环，返回这个环的起始位置" class="headerlink" title="2. 已知链表中含有环，返回这个环的起始位置"></a>2. 已知链表中含有环，返回这个环的起始位置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当快慢指针相遇时，让其中任一个指针指向头结点，然后让他俩以相同的速度前进，再次相遇时所在的节点就是环开始的位置。</p><p>第一次相遇时，假设慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步；</p><p><code>fast</code> 一定比 <code>slow</code> 多走了 <code>k</code> 步，这多走的 <code>k</code> 步就是 <code>fast</code> 指针在环中转圈圈，所以 <code>k</code> 值就是环长度的整数倍。</p><p>设相遇点距环的起点的距离为 <code>m</code> ，那么环的起点距头结点 <code>head</code> 的距离为 <code>k-m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。而巧的是，如果从相遇点继续前进 <code>k-m</code> 步，也恰好到达环起点。</p><p>所以只要将快慢指针中的任一个重新指向 <code>head</code> ，然后两个指针同速前进，<code>k-m</code> 步后就会相遇，相遇之处就是环的起点了。</p><h5 id="3-寻找链表的中点"><a href="#3-寻找链表的中点" class="headerlink" title="3. 寻找链表的中点"></a>3. 寻找链表的中点</h5><p>类似上面的思路，可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slow 就在中间位置</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当链表的长度是奇数时，<code>slow</code> 恰巧停在中点位置；如果长度是偶数， <code>slow</code> 的位置是中间偏右。</p><p>寻找链表中点的一个重要作用是对链表进行归并排序。</p><p>回想数组的归并排序：求中点索引递归的将数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。</p><p>但是现在能够寻找链表的中点，就能实现链表的二分了。</p><h5 id="4-寻找链表的倒数第-n-个元素"><a href="#4-寻找链表的倒数第-n-个元素" class="headerlink" title="4. 寻找链表的倒数第 n 个元素"></a>4. 寻找链表的倒数第 n 个元素</h5><p>删除链表中倒数第 n 个节点。</p><p>思路还是使用快慢指针，让快指针先走 n 步，然后快慢指针同速前进。这样当快指针走到链表末尾 <code>null</code> 时，慢指针所在的位置就是倒数第 n 个链表节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果此时快指针走到头了，说明倒数第 n 个节点就是第一个节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让慢指针和快指针同步向前</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slow.next 就是倒数第 n 个节点</span></span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、左右指针"><a href="#二、左右指针" class="headerlink" title="二、左右指针"></a>二、左右指针</h3><p>左右指针在数组中实际是指两个索引值，一般初始化为 <code>left=0, right=nums.length-1</code></p><h5 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-两数之和"><a href="#2-两数之和" class="headerlink" title="2. 两数之和"></a>2. 两数之和</h5><p>给定一个按升序排列的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>只要数组有序，就应该想到双指针技巧。这题解法类似二分查找，通过调节 <code>left</code> 和 <code>right</code> 可以调整 <code>sum</code> 的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left+<span class="number">1</span>, right+<span class="number">1</span>&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            left++; <span class="comment">// 让 sum 大一点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            right--; <span class="comment">// 让 sum 小一点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-反转数组"><a href="#3-反转数组" class="headerlink" title="3. 反转数组"></a>3. 反转数组</h5><p>一般编程语言都会提供 reverse 函数，其实非常简单，leetcode 344 题是类似需求，反转一个 <code>char[]</code> 类型的字符数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 交换 arr[left] 和 arr[right]</span></span><br><span class="line">        <span class="keyword">char</span> temp = arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-滑动窗口算法"><a href="#4-滑动窗口算法" class="headerlink" title="4. 滑动窗口算法"></a>4. 滑动窗口算法</h5><p>这是双指针技巧的最高境界，掌握该算法，可以解决一大类子字符串匹配的问题，不过滑动窗口算法稍微复杂，详情见滑动窗口的模板框架</p><h5 id="5-接雨水问题"><a href="#5-接雨水问题" class="headerlink" title="5. 接雨水问题"></a>5. 接雨水问题</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxWater</span>(<span class="params"> arr </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[left] &lt; arr[right]) &#123;</span><br><span class="line">            left_max = <span class="built_in">Math</span>.max(left_max, arr[left]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (arr[left] &lt; left_max) &#123;</span><br><span class="line">                res += left_max - arr[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right_max = <span class="built_in">Math</span>.max(right_max, arr[right]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (arr[right] &lt; right_max) &#123;</span><br><span class="line">                res += right_max - arr[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;双指针技巧总结&quot;&gt;&lt;a href=&quot;#双指针技巧总结&quot; class=&quot;headerlink&quot; title=&quot;双指针技巧总结&quot;&gt;&lt;/a&gt;双指针技巧总结&lt;/h2&gt;&lt;p&gt;双指针分为两类，一类是快慢指针，一类是左右指针。前者主要解决链表中的问题，比如典型的判断链表中是否包</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>数组概览</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E6%A6%82%E8%A7%88/</id>
    <published>2022-04-05T14:23:39.245Z</published>
    <updated>2022-04-05T14:31:50.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组概览"><a href="#数组概览" class="headerlink" title="数组概览"></a>数组概览</h2><p>数组是开发中最常见的数据结构了，用于按顺序存储元素的集合。但是元素可以随机存取，因为数组中的每个元素都可以通过索引来识别。插入和删除时要移动后续元素，还要考虑扩容问题，插入速度慢。</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>用于数组的双指针一般是左右指针，但是快慢指针也是适用的。主要<strong>利用两个或多个不同位置的指针，通过速度和方向的变换解决问题</strong>。这种技巧经常在排序数组中使用。</p><ul><li>调整数组顺序使奇数位于偶数前面</li><li>和为 S 的两个数字</li><li>和为 S 的连续正整数序列</li></ul><h3 id="N-数之和问题"><a href="#N-数之和问题" class="headerlink" title="N 数之和问题"></a>N 数之和问题</h3><p>非常常见的问题，基本上另一个套路，主要考虑如何比暴力法降低时间复杂度，而且也会用到双指针技巧</p><ul><li>两数之和</li><li>三数之和</li><li>四数之和</li></ul><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>建立一定的抽象建模能力，将实际中的很多问题进行抽象</p><ul><li>构建乘积数组</li><li>顺时针打印矩阵</li></ul><h3 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h3><p>数组少不了的就是统计和计算，此类问题考察如何利用更高效的方法对数组进行统计计算</p><ul><li>数组中出现次数超过数组长度一半的数字</li><li>连续子数组的最大和</li><li>扑克牌顺子</li><li>第一个只出现一次的字符</li></ul><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="1-调整数组顺序使奇数位于偶数前面"><a href="#1-调整数组顺序使奇数位于偶数前面" class="headerlink" title="1. 调整数组顺序使奇数位于偶数前面"></a>1. 调整数组顺序使奇数位于偶数前面</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[left] % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nums[right] % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">const</span> temp = nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-和为-S-的两个数字"><a href="#2-和为-S-的两个数字" class="headerlink" title="2. 和为 S 的两个数字"></a>2. 和为 S 的两个数字</h4><p>输入一个递增排序的数组和一个数字 S ，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积是最小的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> sum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> [nums[left], nums[right]]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-和为-S-的连续正整数序列"><a href="#3-和为-S-的连续正整数序列" class="headerlink" title="3. 和为 S 的连续正整数序列"></a>3. 和为 S 的连续正整数序列</h4><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）</p><p><strong>思路</strong>：借用滑动窗口实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findContinuousSequence = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">window</span> = [];</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; target) &#123;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="built_in">window</span>.push(right);</span><br><span class="line">        sum += right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sum &gt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="built_in">window</span>.shift();</span><br><span class="line">            sum -= left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum === target &amp;&amp; <span class="built_in">window</span>.length&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            res.push(<span class="built_in">window</span>.slice());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-两数之和"><a href="#4-两数之和" class="headerlink" title="4. 两数之和"></a>4. 两数之和</h4><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code> ，请在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。</p><p>解析：因为数组不是有序的数组，所以不适合利用左右指针去寻找两数之和。可以使用两个 for 循环进行遍历，简单粗暴，但是时间复杂度很高。</p><p>所以使用一个 map 函数将遍历过的数字存储起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.has(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> [map.get(target - nums[i]), i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-三数之和"><a href="#5-三数之和" class="headerlink" title="5. 三数之和"></a>5. 三数之和</h4><p>给定一个包含 n 个整数的数组 <code>nums</code> ，判断 <code>nums</code> 中是否存在三个元素 <code>a,b,c</code> ，使得 <code>a + b + c = 0</code> 找出所有满足条件且不重复的三元组。</p><p><strong>思路：</strong></p><p>因为题目说明可能出现多组结果，有重复数字，所以要考虑好去重。</p><ul><li>为了方便去重，首先将数组进行排序</li><li>对数组进行遍历，取当前遍历的数 <code>nums[i]</code> 为一个基准数，遍历数后面的数组为寻找数组</li><li>在寻找数组中利用左右指针进行遍历</li><li>判断三数之和是否等于 0，如果等于 0 ，加入结果，左右指针分别进行移动一位，同时还要考虑去重。</li><li>结果大于 0 ，<code>right</code> 指针向左移动一位</li><li>结果小于 0，<code>left</code> 指针向右移动一位</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; nums[i] === nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> left = i+<span class="number">1</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">                res.push([nums[i], nums[left], nums[right]]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(nums[left] === nums[left<span class="number">-1</span>]) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(nums[right] === nums[right<span class="number">-1</span>]) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-四数之和"><a href="#6-四数之和" class="headerlink" title="6. 四数之和"></a>6. 四数之和</h4><p>给定一个包含 n 个整数的数组 <code>nums</code> ，判断 <code>nums</code> 中是否存在四个元素 <code>a, b, c, d</code> ，使得 <code>a + b + c + d = 0</code>。找出所有满足条件且不重复的四元组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fourSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt; <span class="number">4</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a-b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length<span class="number">-3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; nums[i] === nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt;nums.length<span class="number">-2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] === nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> left = j+<span class="number">1</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">const</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">                    res.push([nums[i], nums[j], nums[left], nums[right]]);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">while</span>(nums[left] === nums[left<span class="number">-1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(nums[right] === nums[right+<span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-构建数组乘积"><a href="#7-构建数组乘积" class="headerlink" title="7. 构建数组乘积"></a>7. 构建数组乘积</h4><p>给定一个数组 A <code>[0, 1, ..., n-1]</code>，请构建一个数组 B <code>[0, 1, ..., n-1]</code>，其中 B 中的元素 <code>B[i] = A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。</p><p>思路：两种方法</p><p><strong>方法一</strong>：可以使用两个数组，分别从前和从后开始遍历，一个保存前 i 个数的乘积，一个保存后 i 个数的乘积。然后利用这两个数组构建B</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constructArr = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(a.length);</span><br><span class="line">    <span class="keyword">const</span> pre = <span class="keyword">new</span> <span class="built_in">Array</span>(a.length);</span><br><span class="line">    <span class="keyword">const</span> last = <span class="keyword">new</span> <span class="built_in">Array</span>(a.length);</span><br><span class="line"></span><br><span class="line">    pre[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i&lt;a.length; i++) &#123;</span><br><span class="line">        pre[i] = a[i] * pre[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last[a.length<span class="number">-1</span>] = a[a.length<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=a.length<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        last[i] = a[i] * last[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b[<span class="number">0</span>] = last[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;a.length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        b[i] = pre[i<span class="number">-1</span>] * last[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    b[a.length<span class="number">-1</span>] = pre[a.length<span class="number">-2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二：构建对角线元素都为 1 的二维矩阵，<code>B[i]</code> 的值相当于矩阵每行的乘积。可以将 B 数组分为上下两个三角，先计算下三角，然后将上三角乘进去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(array) &amp;&amp; array.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算下三角</span></span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">            result[i] = result[i<span class="number">-1</span>] * array[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 乘上三角</span></span><br><span class="line">        <span class="keyword">let</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            temp = temp * array[i+<span class="number">1</span>];</span><br><span class="line">            result[i] = result[i] * temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-顺时针打印数组"><a href="#8-顺时针打印数组" class="headerlink" title="8. 顺时针打印数组"></a>8. 顺时针打印数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> boundl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> boundr = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> boundt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> boundb = m<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> turn = n === <span class="number">1</span> ? <span class="string">'d'</span> : <span class="string">'r'</span>;</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> a=<span class="number">0</span>; a&lt;m*n; a++) &#123;</span><br><span class="line">        result.push(matrix[i][j]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (turn === <span class="string">'r'</span>) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (j === boundr) &#123;</span><br><span class="line">                turn = <span class="string">'d'</span>;</span><br><span class="line">                boundt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (turn === <span class="string">'d'</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i === boundb) &#123;</span><br><span class="line">                turn = <span class="string">'l'</span>;</span><br><span class="line">                boundr--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (turn === <span class="string">'l'</span>) &#123;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span> (j === boundl) &#123;</span><br><span class="line">                turn = <span class="string">'t'</span>;</span><br><span class="line">                boundb--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (turn === <span class="string">'t'</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">if</span> (i === boundt) &#123;</span><br><span class="line">                turn = <span class="string">'r'</span>;</span><br><span class="line">                boundl++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-数组中出现次数超过数组长度一半的数字"><a href="#9-数组中出现次数超过数组长度一半的数字" class="headerlink" title="9. 数组中出现次数超过数组长度一半的数字"></a>9. 数组中出现次数超过数组长度一半的数字</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(nums.length/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.has(nums[i])) &#123;</span><br><span class="line">            map.set(nums[i], map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(nums[i]) &gt; mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="10-连续子数组的最大和"><a href="#10-连续子数组的最大和" class="headerlink" title="10. 连续子数组的最大和"></a>10. 连续子数组的最大和</h4><p>输入一个整型数组，数组里有正数也有负数。数组的一个或连续多个整数组成一个子数组。求所有子数组的最大值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> max = nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            sum = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用动态规划的思路解决。</p><ul><li>首先对数据进行遍历，当前最大连续子序列和为 sum，结果为 max 。</li><li>如果 <code>sum &gt; 0</code>，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字</li><li>如果 <code>sum &lt; 0</code>，则说明 sum 对结果无增益效果，需要舍弃，sum 直接更新为当前遍历数字。</li><li>敝教教 sum 和 max 大小，将最大值置为 max。</li></ul><h4 id="11-扑克牌顺子"><a href="#11-扑克牌顺子" class="headerlink" title="11. 扑克牌顺子"></a>11. 扑克牌顺子</h4><p>扑克牌中随机抽取 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。</p><p>思路：</p><ul><li>将数组进行排序</li><li>遍历数组，若值为 0 ，记录 0 的个数加 1 ； 若不为 0 ，记录与下一个元素的间隔</li><li>最后比较 0 的个数和间隔数，间隔数大于 0 的个数不能构成顺子</li><li>中间如果有两个元素相等则不能构成顺子。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isStraight = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> zeroCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> spaceCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] === <span class="number">0</span>) zeroCount++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> space = nums[i<span class="number">-1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (space === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                spaceCount += space<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (spaceCount - zeroCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-第一个只出现一次的字符"><a href="#12-第一个只出现一次的字符" class="headerlink" title="12. 第一个只出现一次的字符"></a>12. 第一个只出现一次的字符</h4><p>在一个字符串中找到第一个只出现一次的字符，并返回它的位置，如果没有则返回 -1 。（区分大小写）</p><p><strong>思路：</strong>遍历两次，第一次遍历存储元素出现的次数，第二次遍历找出第一个只出现一次的字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> a = s[i];</span><br><span class="line">        map.has(a) ? map.set(a, map.get(a) + <span class="number">1</span>) : map.set(a, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> a = s[i];</span><br><span class="line">        <span class="keyword">if</span> (map.get(a) === <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">" "</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组概览&quot;&gt;&lt;a href=&quot;#数组概览&quot; class=&quot;headerlink&quot; title=&quot;数组概览&quot;&gt;&lt;/a&gt;数组概览&lt;/h2&gt;&lt;p&gt;数组是开发中最常见的数据结构了，用于按顺序存储元素的集合。但是元素可以随机存取，因为数组中的每个元素都可以通过索引来识别。插</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>数组遍历问题</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-05T14:23:39.243Z</published>
    <updated>2022-04-05T14:31:37.919Z</updated>
    
    <content type="html"><![CDATA[<h4 id="岛屿面积问题"><a href="#岛屿面积问题" class="headerlink" title="岛屿面积问题"></a>岛屿面积问题</h4><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxAreaOfIsland = <span class="function"><span class="params">grid</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> m = grid.length;</span><br><span class="line">    <span class="keyword">const</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">i, j</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;=m || j&lt;<span class="number">0</span> || j&gt;=n || grid[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">1</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>; <span class="comment">// 遍历完之后置空</span></span><br><span class="line">        sum += dfs(i+<span class="number">1</span>, j);</span><br><span class="line">        sum += dfs(i<span class="number">-1</span>, j);</span><br><span class="line">        sum += dfs(i, j<span class="number">-1</span>);</span><br><span class="line">        sum += dfs(i, j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            max = <span class="built_in">Math</span>.max(max, dfs(i, j))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="黄金矿工"><a href="#黄金矿工" class="headerlink" title="黄金矿工"></a>黄金矿工</h4><p>不能重复走</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getMaximumGold = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> m = grid.length;</span><br><span class="line">    <span class="keyword">const</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">r, c, sum</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;=m || c&lt;<span class="number">0</span> || c&gt;=n || grid[r][c] === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> temp = grid[r][c];</span><br><span class="line">        sum += grid[r][c];</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> a = dfs(r+<span class="number">1</span>, c, sum);</span><br><span class="line">        <span class="keyword">let</span> b = dfs(r<span class="number">-1</span>, c, sum);</span><br><span class="line">        <span class="keyword">let</span> e = dfs(r, c<span class="number">-1</span>, sum);</span><br><span class="line">        <span class="keyword">let</span> f = dfs(r, c+<span class="number">1</span>, sum);</span><br><span class="line">        grid[r][c] = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(a, b, e, f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] !== <span class="number">0</span>) &#123;</span><br><span class="line">                max = <span class="built_in">Math</span>.max(max, dfs(i, j, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;岛屿面积问题&quot;&gt;&lt;a href=&quot;#岛屿面积问题&quot; class=&quot;headerlink&quot; title=&quot;岛屿面积问题&quot;&gt;&lt;/a&gt;岛屿面积问题&lt;/h4&gt;&lt;p&gt;给定一个包含了一些 0 和 1 的非空二维数组 grid 。&lt;/p&gt;
&lt;p&gt;一个 岛屿 是由一些相邻的 1 </summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>十大经典排序算法</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-05T14:23:39.240Z</published>
    <updated>2022-04-05T14:31:11.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h2><p>十种常见的排序算法可以分为两大类：</p><ul><li><strong>比较类排序：</strong>通过比较来决定元素间的相对次序。因为时间复杂度不能突破 <code>O(NlogN)</code>，所以也称为非线性时间比较类排序</li><li><strong>非比较类排序：</strong>不通过比较来决定元素间的相对次序，可以突破基于比较排序的时间下界，以线性时间运行，也称线性时间非比较类排序</li></ul><p><img src="C:%5CUsers%5Ccheng%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210707145714938.png" alt="image-20210707145714938"></p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>稳定：如果 a 原本在 b 前面，a = b，排序之后 a 仍然在 b 的前面</li><li>不稳定：如果 a 原本在 b 的前面，而 a = b，排序之后 a 可能出现在 b 的后面</li><li>时间复杂度：对排序数据总的操作次数。反映当 n 变化时，操作次数呈现什么规律</li><li>空间复杂度：指算法在计算机内执行时所需存储空间的度量，也是数据规模 n 的函数</li></ul><table><thead><tr><th>排序方法</th><th align="center">时间复杂度（平均）</th><th align="center">时间复杂度（最坏）</th><th align="center">时间复杂度（最好）</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td align="center">O(n*n)</td><td align="center">O(n*n)</td><td align="center">O(n)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td>选择排序</td><td align="center">O(n*n)</td><td align="center">O(n*n)</td><td align="center">O(n*n)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td>插入排序</td><td align="center">O(n*n)</td><td align="center">O(n*n)</td><td align="center">O(n)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td>快速排序</td><td align="center">O(n*log n)</td><td align="center">O(n*n)</td><td align="center">O(n*log n)</td><td align="center">O(1) / O(log n)</td><td align="center">不稳定</td></tr><tr><td>希尔排序</td><td align="center">O(n^1.3)</td><td align="center">O(n*n)</td><td align="center">O(n)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td>堆排序</td><td align="center">O(n*log n)</td><td align="center">O(n*log n)</td><td align="center">O(n*log n)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td>归并排序</td><td align="center">O(n*log n)</td><td align="center">O(n* log n)</td><td align="center">O(n*log n)</td><td align="center">O(n)</td><td align="center">稳定</td></tr><tr><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>计数排序</td><td align="center">O(n + k)</td><td align="center">O(n + k)</td><td align="center">O(n + k)</td><td align="center">O(n + k)</td><td align="center">稳定</td></tr><tr><td>桶排序</td><td align="center">O(n + k)</td><td align="center">O(n*n)</td><td align="center">O(n + k)</td><td align="center">O(n + k)</td><td align="center">稳定</td></tr><tr><td>基数排序</td><td align="center">O(n*k)</td><td align="center">O(n*k)</td><td align="center">O(n*k)</td><td align="center">O(n + k)</td><td align="center">稳定</td></tr></tbody></table><p>$$</p><p>$$</p><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>冒泡排序重复走访过要排序的数列，一次比较两个元素，如果顺序错误就交换。每一次遍历都将固定一个值，最大或最小。这个算法名字的由来是因为越小的元素会经由交换慢慢浮到数列的顶端。</p><p><strong>算法描述：</strong></p><ul><li>比较相邻的元素，如果第一个比第二个大，就交换它们</li><li>对每一对相邻元素做同样的工作，从开始到最后，这样在最后的元素应该会是最大的数</li><li>针对所有的元素重复以上的步骤，除了最后一个</li><li>重复步骤 1~3，知道排序完成</li></ul><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;len-i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">                arr[i+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序的元素中寻找最小（大）元素，然后放到已排序序列的末尾。直到所有元素排序完毕。</p><p><strong>算法描述：</strong></p><p>n 个记录的直接选择排序可经过 n - 1 趟直接选择排序得到有序结果。</p><ul><li>初始状态：无序区为 R[1..n]，有序区为空；</li><li>第 i 趟开始时，当前有序区和无序区分别为 R[1..i-1] 和 R[i..n] 。该趟排序从当前无序区中选出关键字最小的记录 R[k] ，将其与无序区的第 1 个记录 R 交换，使 R[1..i] 和 R[i+1..n] 分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区</li><li>n - 1 趟结束，数组有序化了。</li></ul><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=i+<span class="number">1</span>; j&lt;len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法分析：</strong></p><p>表现最稳定的排序算法之一，因为无论什么数据进去都是 <code>O(n^2)</code> 的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处是不占用额外的内存空间。</p><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><p>插入排序工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p><p><strong>算法描述：</strong></p><ul><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已排序的元素序列中从后向前扫描</li><li>如果该元素大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤 2~5</li></ul><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> preIndex = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">const</span> current = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h3><p>希尔排序和插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong></p><p><strong>实质上是分组插入排序</strong></p><p><strong>算法描述：</strong></p><p>先将整个待排序的记录序列分割称为若干自许雷分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列 <code>t1, t2, ..., tk</code>，其中 </li><li>按增量序列个数 k ，对序列进行 k 趟排序</li><li>每趟排序，根据对应的增量 ti，将带排序列分割成若干长度的子序列，分别对各子表进行直接插入排序</li></ul><p>比如数组 <code>[7,6,9,3,1,5,2,4]</code></p><p>希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序。</p><p>选择增量 gap = length/2，缩小增量以 gap = gap / 2 的方式</p><ul><li>第一趟排序：[1, 5, 2, 3, 7, 6, 9, 4]; gap = 4。</li><li>第二趟排序：[1, 3, 2, 4, 7, 5, 9, 6]; gap = 2。</li><li>第三趟排序：[1, 2, 3, 4, 5, 6, 7, 9]; gap = 1</li></ul><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>); gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> j = i;</span><br><span class="line">            <span class="keyword">const</span> current = arr[i];</span><br><span class="line">            <span class="keyword">while</span>(j-gap &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">                j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><p>该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p><p><strong>算法描述：</strong></p><ul><li>把长度为 n 的输入序列分成两个长度为 n/2 的子序列</li><li>对这两个子序列分别采用归并排序</li><li>将两个排序好的子序列合并成一个最终的排序序列</li></ul><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> middle = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">const</span> right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">while</span>(left.length&gt;<span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left.length) &#123;</span><br><span class="line">        result.push(left.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right.length) &#123;</span><br><span class="line">        result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法分析：</strong></p><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 <code>O(nlogn)</code>的时间复杂度。代价是需要额外的内存空间。</p><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，</p><p><strong>算法描述：</strong></p><p>从数列中挑出一个元素作为基准，重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面。在这个分区退出后，该基准就处于数列的中间位置。</p><p>递归地把小于基准值元素的子数列和大于基准值元素的子序列排序</p><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> partitionIndex;</span><br><span class="line">    <span class="keyword">const</span> left = <span class="keyword">typeof</span> left !== <span class="string">'number'</span> ? <span class="number">0</span> : left;</span><br><span class="line">    <span class="keyword">const</span> right = <span class="keyword">typeof</span> right !== <span class="string">'number'</span> ? len<span class="number">-1</span> : right;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex<span class="number">-1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left ,right</span>) </span>&#123;     <span class="comment">// 分区操作</span></span><br><span class="line">    <span class="keyword">var</span> pivot = left,                      <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><p>堆排序是指利用堆这种数据结构设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。</p><ul><li>大顶堆：每个节点的值大于或等于其左右孩子节点的值，称为大顶堆</li><li>小顶堆：每个节点的值小于或等于其左右孩子节点的值，称为小顶堆</li></ul><p><strong>算法描述：</strong></p><ul><li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</li><li>将堆顶元素与末尾元素交换，将最大元素沉到数组末端</li><li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素</li><li>反复执行调整 + 交换步骤，直到整个序列有序</li></ul><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p><strong>算法描述：</strong></p><ul><li>找出待排序的数组中最大和最小的元素</li><li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项。</li><li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）</li><li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就近将 C(i) 减去 1。</li></ul><p><strong>算法分析：</strong></p><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0 到 k 之间的整数时，时间复杂度是 <code>O(n+k)</code>，空间复杂度也是 <code>O(n+k)</code>，其排序速度快于任何比较排序算法。当 k 不是很大并且序列比较集中时，计数排序时一个很有效的排序算法。</p><h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h3><p>桶排序是计数排序的升级版。他利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分配到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）</p><p><strong>算法描述：</strong></p><ul><li>设置一个定量的数组当作空桶</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去</li><li>对每个不是空的桶进行排序</li><li>从不是空的桶里把排好序的数据拼接起来</li></ul><p><strong>算法分析：</strong></p><p>桶排序最好情况下使用线性时间 <code>O(n)</code>，桶排序的时间复杂度，取决于各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 <code>O(n)</code>。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><p><strong>算法描述：</strong></p><ul><li>取得数组中的最大数，并取得位数</li><li>arr 为原始数组，从最低位开始取每个位组成 radix 数组</li><li>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）</li></ul><p><strong>算法分析：</strong></p><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的同分配都需要 <code>O(n)</code> 的时间复杂度，而且分配之后得到新的关键字序列又需要 <code>O(n)</code> 的时间复杂度。假如待排数据可以分为 d 个关键字，则基数排序的时间复杂度将是 <code>O(d*2n)</code>，当然 d 要远远小于 n，因此基本还是线性级别的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;十大经典排序算法&quot;&gt;&lt;a href=&quot;#十大经典排序算法&quot; class=&quot;headerlink&quot; title=&quot;十大经典排序算法&quot;&gt;&lt;/a&gt;十大经典排序算法&lt;/h2&gt;&lt;p&gt;十种常见的排序算法可以分为两大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;比较类排序：&lt;</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>链表概览</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E6%A6%82%E8%A7%88/</id>
    <published>2022-04-05T14:23:39.237Z</published>
    <updated>2022-04-05T14:30:50.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表系列"><a href="#链表系列" class="headerlink" title="链表系列"></a>链表系列</h2><p>用一组任意存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。</p><ul><li>需要遍历才能查询到元素，查询慢</li><li>插入元素只需要断开连接重新赋值，插入快</li></ul><h3 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h3><p>主要是对链表基本概念和特性的应用，如果基础概念掌握牢靠，此类问题即可解决。</p><ul><li>从尾到头打印链表</li><li>删除链表中的节点</li><li>反转链表</li><li>复杂链表的复制</li></ul><h3 id="环类题目"><a href="#环类题目" class="headerlink" title="环类题目"></a>环类题目</h3><p>环类链表即从判断一个单链表是否存在循环而扩展衍生的问题</p><ul><li>环形链表</li><li>链表环的入口节点</li><li>约瑟夫环</li></ul><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>双指针的思想在链表和数组中的题目都会经常用到，主要是利用两个或多个不同位置的指针，通过速度和方向的变换解决问题。比如快慢指针和左右指针。</p><ul><li>左右指针：两个指针从不同位置出发，一个从始端开始，一个从末端开始</li><li>快慢指针：两个指针以不同速度移动，一个指针快一些，一个指针慢一些。</li></ul><p>对于单链表，因为只能在一个方向上遍历链表，所以左右指针很难实施，但快慢指针是非常适用的。</p><ul><li>两个链表的公共节点</li><li>链表的倒数第 k 个节点</li><li>相交链表</li></ul><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双链还有一个引用字段，称为 <code>prev</code> 字段，有了这个额外的字段，就可以知道当前节点的前一个结点</p><ul><li>扁平化多级双向链表</li></ul><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="1-从尾到头打印链表"><a href="#1-从尾到头打印链表" class="headerlink" title="1. 从尾到头打印链表"></a>1. 从尾到头打印链表</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printListFromTailToHead</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [];</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">        arr.unshift(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-删除链表中的结点"><a href="#2-删除链表中的结点" class="headerlink" title="2. 删除链表中的结点"></a>2. 删除链表中的结点</h4><ul><li>删除的结点不是尾部结点：next 结点覆盖当前结点</li><li>删除的结点是尾部结点且等于头结点，只剩一个结点：将头结点置为 <code>null</code></li><li>删除的结点是尾结点且前面还有结点：遍历到末尾的前一个结点删除</li></ul><p>只有第三种情况的时间复杂度是 <code>O(n)</code>，且这种情况只会出现 <code>1/n</code> 次，所以算法的时间复杂度是 <code>O(1)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.val == val) <span class="keyword">return</span> head.next;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur.next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.next.val == val) &#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>删除表中重复的结点</strong></p><p>可以存储链表中元素出现的次数，用一个 map 存储每个结点出现的次数，删除出现次数大于 1 的结点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteDuplication</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    map.set(cur.val, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(cur.next) &#123;</span><br><span class="line">        map.set(cur.next.val, map.has(cur.next.val) ? map.get(cur.next.val) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (map.get(cur.next.val) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-反转链表"><a href="#3-反转链表" class="headerlink" title="3. 反转链表"></a>3. 反转链表</h4><p>输入一个链表，反转链表后，输出新链表的表头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="keyword">const</span> next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="params">head</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> last = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-复杂链表的复制"><a href="#4-复杂链表的复制" class="headerlink" title="4. 复杂链表的复制"></a>4. 复杂链表的复制</h4><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。</p><h4 id="5-环形链表"><a href="#5-环形链表" class="headerlink" title="5. 环形链表"></a>5. 环形链表</h4><p>给定一个链表，判断链表中是否有环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast,slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-环形链表入口节点"><a href="#6-环形链表入口节点" class="headerlink" title="6. 环形链表入口节点"></a>6. 环形链表入口节点</h4><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!fast || !fast.next) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-约瑟夫环"><a href="#7-约瑟夫环" class="headerlink" title="7. 约瑟夫环"></a>7. 约瑟夫环</h4><p><code>0,1,...,n-1</code> 这 n 个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第 m 个数字。求出这个圆圈里剩下的最后一个数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LastRemaining_Solution</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">1</span> || m&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先用链表模拟环</span></span><br><span class="line">    <span class="keyword">const</span> head = &#123; <span class="attr">val</span>:<span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> current = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        curren.next = &#123;<span class="attr">val</span> : i&#125;;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current.next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(current.next != current) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = current.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-两个链表的第一个公共节点"><a href="#8-两个链表的第一个公共节点" class="headerlink" title="8. 两个链表的第一个公共节点"></a>8. 两个链表的第一个公共节点</h4><p>输入两个链表，找出它们的第一个公共节点</p><ul><li>先找到两个链表的长度</li><li>让长一点的链表先走，让长链表和短链表起点相同</li><li>两个链表一起前进，比较获得第一个相等的节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindFirstCommonNode</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取链表长度</span></span><br><span class="line">    <span class="keyword">let</span> lengthA = getLength(headA);</span><br><span class="line">    <span class="keyword">let</span> lengthB = getLength(headB);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lengthA &gt; lengthB) &#123;</span><br><span class="line">        <span class="keyword">let</span> interver = lengthA - lengthB;</span><br><span class="line">        <span class="keyword">while</span>(interver) &#123;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">            interver--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> interver = lengthB - lengthA;</span><br><span class="line">        <span class="keyword">while</span>(interver) &#123;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">            interver--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(headA) &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == headB) &#123;</span><br><span class="line">            <span class="keyword">return</span> headA;</span><br><span class="line">        &#125;</span><br><span class="line">        headA = headA.next;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> current = head;</span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-链表的倒数第-k-个节点"><a href="#9-链表的倒数第-k-个节点" class="headerlink" title="9. 链表的倒数第 k 个节点"></a>9. 链表的倒数第 k 个节点</h4><p>输入一个链表，输出链表中倒数第 k 个节点。</p><p>使用快慢指针，让快指针先走 k 步，然后同速前进，快指针到达终点时慢指针指向倒数第 k 个节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findKthToTail</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast,slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果此时走到头了，则说明倒数第 k 个节点就是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (!fast) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="连续数组"><a href="#连续数组" class="headerlink" title="连续数组"></a>连续数组</h4><p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaxLength = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">    map.set(counter, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> num = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.has(counter)) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevIndex = map.get(counter);</span><br><span class="line">            maxLength = <span class="built_in">Math</span>.max(maxLength, i - prevIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(counter, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链表系列&quot;&gt;&lt;a href=&quot;#链表系列&quot; class=&quot;headerlink&quot; title=&quot;链表系列&quot;&gt;&lt;/a&gt;链表系列&lt;/h2&gt;&lt;p&gt;用一组任意存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要遍历才能查询到元素</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>解决nSum问题</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E8%A7%A3%E5%86%B3%20nSum%20%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E8%A7%A3%E5%86%B3%20nSum%20%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-05T14:23:39.234Z</published>
    <updated>2022-04-05T14:30:32.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决-nSum-问题"><a href="#解决-nSum-问题" class="headerlink" title="解决 nSum 问题"></a>解决 <code>nSum</code> 问题</h2><h3 id="twoSum问题"><a href="#twoSum问题" class="headerlink" title="twoSum问题"></a><code>twoSum</code>问题</h3><p>leetcode 上经典的问题，假设输入一个数组 <code>nums</code> 和一个目标 <code>target</code>，要求返回能凑出目标值的索引。</p><p>如果不要求返回索引而是返回凑出 <code>target</code> 的两个元素的值，那我们可以先将数组进行排序，然后利用左右指针的方法进行寻找即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a - b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">const</span> sum = nums[left] + nums[right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> [nums[left], nums[right]];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能够解决问题，但是这题目是假设 <code>nums</code> 中有且只有一个答案，但如果修改这个条件：<code>nums</code> 中可能有多对元素之和都等于 <code>target</code> 。要求返回所有和为 <code>target</code> 的元素对，其中不能出现重复。</p><p>这里要注意，<strong>要求去掉重复，所以在判断相等之后，还要注意进行去重</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> sum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">            result.push([nums[left], nums[right]]);</span><br><span class="line">            <span class="keyword">while</span>(nums[left+<span class="number">1</span>] == nums[left]) &#123;</span><br><span class="line">                left++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(nums[right<span class="number">-1</span>] == nums[right]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个通用的 <code>twoSum</code> 函数就写出来了，后面的 <code>threeSum</code> 和 <code>fourSum</code> 都会复用这个函数。</p><h3 id="二、3Sum-问题"><a href="#二、3Sum-问题" class="headerlink" title="二、3Sum 问题"></a>二、3Sum 问题</h3><p>判断数组 <code>nums</code> 中是否存在三个元素使得 <code>a + b + c = target</code> ，找出所有满足条件且不重复的三元组.</p><p>思路：想找和为 <code>target</code> 的三个数字，对于第一个数字，<code>nums</code> 中每一个元素 <code>nums[i]</code> 都有可能。确定了第一个数字后，剩下的两个数就是和为 <code>target - nums[i]</code> 的两个数，即 <code>twoSum</code> 函数的解决方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, start, target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 左指针改为 start 开始，其它不变</span></span><br><span class="line">    <span class="keyword">let</span> left = start, right = nums.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> two = twoSum(nums, i+<span class="number">1</span>, target-nums[i]);</span><br><span class="line">        <span class="keyword">for</span> (item <span class="keyword">of</span> two) &#123;</span><br><span class="line">            item.push(nums[i]);</span><br><span class="line">            res.push(item.slice());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳过数字重复的情况</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n<span class="number">-1</span> &amp;&amp; nums[i] === nums[i+<span class="number">1</span>]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 <code>twoSum</code> ，<code>threeSum</code> 的结果也可能重复。<strong>关键点在于不能使第一个数重复，至于后面两个数，复用的 <code>twoSum</code> 函数会保证它们不重复</strong>。</p><p>至此，<code>threeSum</code> 问题就解决了。</p><h3 id="三、fourSum-问题"><a href="#三、fourSum-问题" class="headerlink" title="三、fourSum 问题"></a>三、fourSum 问题</h3><p><code>fourSum</code> 问题完全可以用相同的思路：穷举第一个数字，然后调用 <code>threeSum</code> 函数计算剩下的三个数，最后组合出和为 <code>target</code> 的四元组。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;解决-nSum-问题&quot;&gt;&lt;a href=&quot;#解决-nSum-问题&quot; class=&quot;headerlink&quot; title=&quot;解决 nSum 问题&quot;&gt;&lt;/a&gt;解决 &lt;code&gt;nSum&lt;/code&gt; 问题&lt;/h2&gt;&lt;h3 id=&quot;twoSum问题&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-05T14:23:39.227Z</published>
    <updated>2022-04-05T14:30:16.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯算法其实就是常说的 DFS 算法，本质上就是一种暴力穷举算法。</p><p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。只需要思考三个问题：</p><ol><li>路径：也就是已经做出的选择</li><li>选择列表：当前可以做的选择</li><li>结束条件：到达决策树底层，无法再做选择的条件</li></ol><p>回溯算法的框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径，选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p><strong>其核心就是 for 循环里面的递归，在递归调用之前做选择，在递归调用之后撤销选择。</strong></p><h3 id="一、全排列问题"><a href="#一、全排列问题" class="headerlink" title="一、全排列问题"></a>一、全排列问题</h3><p>排列组合问题。n 个不重复的数，全排列共有 <code>n!</code> 个。</p><p><strong>PS：为了简单起见，这次讨论的全排列问题不包含重复的数字</strong></p><p>比方说给三个数 <code>[1, 2, 3]</code>，如何穷举全排列。</p><p><img src="https://labuladong.github.io/algo/images/backtracking/1.jpg" alt="全排列"></p><p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。不妨<strong>将这棵树成为回溯算法的 “决策树”</strong></p><p>为什么说这是决策树，因为在每个节点上其实都在做决策。</p><p>可以将 “路径” 和 “选择” 列表作为决策树上每个节点的属性。</p><p>定义的 backtrack 函数其实就像一个指针，在这棵树上游走，同时要正确的维护每个节点的属性，每当走到树的底层，其路径就是一个全排列。</p><p>再进一步就是如何遍历一棵树，多叉树的遍历如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        <span class="comment">// 前序遍历需要的操作</span></span><br><span class="line">        traverse(child);</span><br><span class="line">        <span class="comment">// 后序遍历需要的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓的前序遍历和后序遍历，只是两个很有用的时间点。<strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行</strong></p><p>“路径”和“选择”是每个节点的属性，函数在树上游走要正确维护节点的属性，就需要在这两个特殊时间点搞点动作。</p><p><strong>前序的节点做选择，后序的节点撤销选择</strong></p><p>现在再回看回溯算法的核心框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径，选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure><p><strong>只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径</p><p>全排列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数，输入一组不重复的数字，返回它们的全排列*/</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录路径</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：记录在 track 中</span></span><br><span class="line"><span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line"><span class="comment">// 结束条件：nums 中元素全部在 track 中出现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全排列的 JS 代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> track = [];</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> trackback = <span class="function">(<span class="params">nums, track</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length === track.length) &#123;</span><br><span class="line">            result.push(track.slice());  <span class="comment">// 使用slice方法进行复制</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(track.includes(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            track.push(nums[i]);</span><br><span class="line">            trackback(nums, track);</span><br><span class="line">            track.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trackback(nums, track);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里稍微做了变通，没有显示记录“选择列表”，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表。</p><p>这个算法解决全排列不是很高效。但是不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 <code>O(N)</code>，因为穷举整棵决策树是无法避免的。<strong>这是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong></p><p><strong>提升</strong></p><p>上面是假设数组中没有重复出现的元素，现在将难度进行升级，如果数组中存在重复元素，如何进行全排列，且去除重复的组合</p><ul><li>首先不能使用 track 来判断是否出现过元素</li><li>改用 <code>visited</code> 对象，用来保存是否遍历过 i </li><li>用 <code>inclu</code> 数组来去除每次选择时去除重复选择的对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> track = [];</span><br><span class="line">    <span class="keyword">const</span> visited = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> backtrack = <span class="function"><span class="keyword">function</span>(<span class="params">nums, track</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (track.length === nums.length) &#123;</span><br><span class="line">            result.push(track.slice());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> inclu = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (inclu.includes(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            inclu.push(nums[i]);</span><br><span class="line">            track.push(nums[i]);</span><br><span class="line">            backtrack(nums, track);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.pop();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span>(<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> track = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> backtrack = <span class="function"><span class="keyword">function</span>(<span class="params">track, start</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (track.length === k) &#123;</span><br><span class="line">            res.push(track.slice());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=start; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (track.includes(i+<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            track.push(i+<span class="number">1</span>);</span><br><span class="line">            backtrack(track, i);</span><br><span class="line">            track.pop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(track, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串大小写全排列"><a href="#字符串大小写全排列" class="headerlink" title="字符串大小写全排列"></a>字符串大小写全排列</h4><p>给定一个字符串<code>S</code>，通过将字符串<code>S</code>中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letterCasePermutation = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> track = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> backtrack = <span class="function"><span class="keyword">function</span>(<span class="params">track, i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>  (track.length === s.length) &#123;</span><br><span class="line">            res.push(track.slice().join(<span class="string">''</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(s[i])) &#123;</span><br><span class="line">            track.push(s[i].toLowerCase());</span><br><span class="line">            backtrack(track, i+<span class="number">1</span>);</span><br><span class="line">            track.pop();</span><br><span class="line"></span><br><span class="line">            track.push(s[i].toUpperCase());</span><br><span class="line">            backtrack(track, i+<span class="number">1</span>);</span><br><span class="line">            track.pop();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            track.push(s[i])</span><br><span class="line">            backtrack(track, i+<span class="number">1</span>);</span><br><span class="line">            track.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    backtrack(track,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二、N皇后问题"><a href="#二、N皇后问题" class="headerlink" title="二、N皇后问题"></a>二、N皇后问题</h3><p>给你一个 N*N 的棋盘，让你放置 N 个皇后，使得它们不能相互攻击。</p><p>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p><p>这个问题本质上跟全排列问题差不多，决策树的每一层标识棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p><p>直接套用框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入棋盘边长n，返回所有合法的放置*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// '.'表示空，'Q'表示皇后，初始化空棋盘</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line">    backtrack(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：board 中小于 row 的行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = board[row].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isValid(board, row, col)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        <span class="comment">// 进入下一行决策</span></span><br><span class="line">        backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分主要代码，和全排列问题差不多，<code>isValid</code>函数的实现也很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*是否可以在 board[row][col] 放置皇后*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.size();</span><br><span class="line">    <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=row<span class="number">-1</span>,j=col+<span class="number">1</span>; i&gt;=<span class="number">0</span>&amp;&amp;j&lt;n; i--,j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=row<span class="number">-1</span>,j=col<span class="number">-1</span>; i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>; i--,j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>backtrack</code> 依然像个在决策树上游走的指针，通过 <code>row</code> 和 <code>col</code> 就可以表示函数遍历到的位置，通过 <code>isValid</code>函数可以将不符合条件的情况剪枝。</p><h3 id="三、最后总结"><a href="#三、最后总结" class="headerlink" title="三、最后总结"></a>三、最后总结</h3><p>回溯算法就是多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(...)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(...)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p><strong>写 backtrack 函数时，需要维护走过的路径和当前可以做的选择列表，当触发结束条件时，将路径记入结果集。</strong></p><p>回想一下，回溯算法和动态规划。动态规划中，三个需要明确的点就是：状态、选择、base case。对应着就是走过的路径、当前的选择列表和结束条件。</p><p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而上面的两个问题都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回溯算法&quot;&gt;&lt;a href=&quot;#回溯算法&quot; class=&quot;headerlink&quot; title=&quot;回溯算法&quot;&gt;&lt;/a&gt;回溯算法&lt;/h2&gt;&lt;p&gt;回溯算法其实就是常说的 DFS 算法，本质上就是一种暴力穷举算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决一个回溯问题，实际上就</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>滑动窗口算法框架</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-05T14:23:39.224Z</published>
    <updated>2022-04-05T14:30:02.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口算法框架"><a href="#滑动窗口算法框架" class="headerlink" title="滑动窗口算法框架"></a>滑动窗口算法框架</h2><p>关于双指针的快慢指针和左右指针的用法，可以参考双指针技巧。本文就解决一类最难掌握的双指针技巧：<strong>滑动窗口技巧</strong>。</p><p>滑动窗口算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案。</p><p>该算法的大致逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度是 <code>O(N)</code> ，比字符串暴力算法要高效的多</p><p>而困扰的不是算法的思路，而是各种细节问题。比如如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的那个阶段更新结果。</p><p><strong>滑动窗口算法的代码框架</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*滑动窗口算法框架*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">        <span class="comment">/*debug 输出的位置*/</span></span><br><span class="line">        printf(<span class="string">"window: [%d, %d)\n"</span>, left, right);</span><br><span class="line">        <span class="comment">/******************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中两处 <code>...</code> 表示的更新窗口数据的地方，到时候直接往里面填即可。</p><p>而且这两个 <code>...</code> 处的操作分别是右移和左移窗口更新操作，它们的操作是完全对称的。</p><p>滑动窗口很多时候都是在处理字符串相关的问题，Java 处理字符串不方便，代码使用 C++ 实现。</p><p><code>unordered_map</code> 就是哈希表（字典），它的一个方法 <code>count(key)</code> 相当于 Java 的 <code>containsKey(key)</code> 可以判断键 <code>key</code> 是否存在。</p><p>可以使用方括号访问键对应的值 <code>map[key]</code> 。需要注意的是，如果该 <code>key</code> 不存在，C++ 会自动创建这个 key，并将 <code>map[key]</code> 赋值为 0.</p><h3 id="一、最小覆盖子串"><a href="#一、最小覆盖子串" class="headerlink" title="一、最小覆盖子串"></a>一、最小覆盖子串</h3><p>leetcode 76 题：给一个字符串 S、一个字符串 T，请在字符串 S 里找出：包含 T 所有字母的最小子串。</p><p>即：在 S 中找到包含 T 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p><p>如果使用暴力解法，大概是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;s.size(); j++)</span><br><span class="line">        <span class="keyword">if</span> s[i:j] 包含 t 的所有字母:</span><br><span class="line">    更新答案</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很直接，但是这样算法的复杂度肯定大于 <code>O(N^2)</code> 了。</p><p><strong>滑动窗口的思路：</strong></p><ol><li>在字符串 <code>S</code> 中使用双指针的左右指针技巧，初始化 <code>left = right = 0</code>，把索引左闭右开区间 <code>[left, right)</code> 称为一个窗口。</li><li>先不断的增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code> ，直到窗口中的字符符合要求</li><li>此时停止增加 <code>right</code> ，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code> ，直到窗口中的字符串不再符合要求。同时，每次增加 <code>left</code> 都要更新一轮结果。</li><li>重复第 2 步和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</li></ol><p>这个思路其实不难，<strong>第二步相当于在寻找一个可行解，第三步在优化这个可行解，最终找到最优解</strong>，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p><p><code>needs</code> 和 <code>window</code> 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。</p><p><strong>现在看看这个滑动窗口代码框架的使用</strong>：</p><p>首先，初始化 <code>window</code> 和 <code>need</code> 两个哈希表，记录窗口中的字符和需要凑齐的字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c:t) need[c]++;</span><br></pre></td></tr></table></figure><p>然后使用 <code>left</code> 和 <code>right</code> 变量初始化窗口的两端，不要忘记，区间 <code>[left, right)</code> 是左闭右开的，所以初始情况下窗口没有包含任何元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 开始滑动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中 <code>valid</code> 变量表示窗口中满足 <code>need</code> 条件的字符个数</strong>，如果 <code>valid</code> 和 <code>need.size()</code> 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 T。</p><p>只需思考以下四个问题：</p><ol><li>当移动 <code>right</code> 扩大窗口，即加入字符时，应该更新哪些数据</li><li>什么条件下，窗口应该暂停扩大，开始移动 <code>left</code> 缩小窗口</li><li>当移动 <code>left</code> 缩小窗口，即移除字符时，应该更新哪些数据</li><li>需要的结果应该在扩大窗口时还是缩小窗口时进行更新。</li></ol><p>如果一个字符进入窗口，应该增加 <code>window</code> 计数器；如果一个字符将移除窗口的时候，应该减少 <code>window</code> 计数器；当 <code>valid</code> 满足 <code>need</code> 时应该收缩窗口；应该在收缩创就的时候更新结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    unordered_mp&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">            <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最小覆盖子串</span></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ? <span class="string">""</span> : s.substr(start,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，当发现某个字符在 <code>window</code> 的数量满足了 <code>need</code> 的需要，就要更新 <code>valid</code> ，表示有一个字符已经满足要求。而且两次对窗口内数据的更新操作时完全对称的。</p><p>当 <code>valid == need.size()</code>时，说明 <code>T</code> 中字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该收缩窗口了，以便得到最小覆盖子串。</p><p>移动 <code>left</code> 收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。</p><h3 id="二、字符串排列"><a href="#二、字符串排列" class="headerlink" title="二、字符串排列"></a>二、字符串排列</h3><p>leetcode 567 题：给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。</p><p>注意：输入的 <code>s1</code> 时可以包含重复字符的。</p><p>这是明显的滑动窗口算法，<strong>相当于给一个 S 和一个 T，问 S 中是否存在一个子串，包含 T 中的所有字符且不包含其它字符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 s 中是否有 t 的排列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> t, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (need[c] == window[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.size()) &#123;</span><br><span class="line">            <span class="comment">// 判断是否找到合法的子串</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (need[d] == window[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的解法代码，基本上跟最小覆盖子串一模一样，只需要改变两个地方。</p><ol><li>本题移动 <code>left</code> 缩小窗口的时机是窗口大小大于 <code>t.size()</code> 时，排列显然长度应该是一样的</li><li>当发现 <code>valid == need.size()</code> 时，就说明窗口中就是一个合法的排列，所以立即返回 <code>true</code></li></ol><p>附加：JS 代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> checkInclusion = <span class="function"><span class="keyword">function</span> (<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">window</span> = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">const</span> need = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> s1) need.set(c, need.has(c) ? need.get(c) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right &lt; s2.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> c = s2[right];</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新数据</span></span><br><span class="line">    <span class="keyword">if</span> (need.has(c)) &#123;</span><br><span class="line">      <span class="built_in">window</span>.set(c, <span class="built_in">window</span>.has(c) ? <span class="built_in">window</span>.get(c) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.get(c) == need.get(c)) &#123;</span><br><span class="line">        valid++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right - left &gt;= s1.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (valid == need.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> d = s2[left];</span><br><span class="line">      left++;</span><br><span class="line">      <span class="keyword">if</span> (need.has(d)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.get(d) == need.get(d)) &#123;</span><br><span class="line">          valid--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">window</span>.set(d, <span class="built_in">window</span>.get(d) - <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三、找出所有字母异位词"><a href="#三、找出所有字母异位词" class="headerlink" title="三、找出所有字母异位词"></a>三、找出所有字母异位词</h3><p>leetcode 438 题：给定一个字符串 s 和一个非空字符串 p，找到 s 中所有事 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>（字母异位词指字母相同，但排列不同的字符串）</p><p><strong>相当于，输入一个串 S ，一个串 T ，找到 S 中所有 T 的排列，返回它们的起始索引</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> t) &#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c:t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= t.size()) &#123;</span><br><span class="line">            <span class="comment">// 当窗口符合条件时，把起始索引加入 res</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.size()) &#123;</span><br><span class="line">                res.push_back(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入 <code>res</code> 即可。</p><h3 id="四、最长无重复子串"><a href="#四、最长无重复子串" class="headerlink" title="四、最长无重复子串"></a>四、最长无重复子串</h3><p>leetcode 3 题：给定一个字符串，找出其中不含有重复字符的最长子串的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        window[c]++;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里更新答案</span></span><br><span class="line">        res = max(res, right-left)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是变得简单了，连 <code>need</code> 和 <code>valid</code> 都不需要，而且更新窗口内数据也只需要简单的更新计数器 window 即可。</p><p>当 <code>window[c]</code> 值大于 1 时，说明窗口中年存在重复字符，不符合条件，就该移动 <code>left</code> 缩小窗口</p><p>唯一需要注意的是在哪里更新结果 <code>res</code> 。这里要在收缩窗口完成后更新 <code>res</code> ，因为窗口收缩的 <code>while</code> 条件是存在重复元素，也就是收缩完成后一定保证窗口中没有重复。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;滑动窗口算法框架&quot;&gt;&lt;a href=&quot;#滑动窗口算法框架&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口算法框架&quot;&gt;&lt;/a&gt;滑动窗口算法框架&lt;/h2&gt;&lt;p&gt;关于双指针的快慢指针和左右指针的用法，可以参考双指针技巧。本文就解决一类最难掌握的双指针技巧</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>后序遍历</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-04-05T14:23:39.221Z</published>
    <updated>2022-04-05T14:29:37.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>二叉树的题目，无非就是前中后序遍历来回倒，但对于有的题目，不同的遍历顺序，复杂度不同。</p><p><strong>二叉树相关的题目最核心的思路就是明确当前节点需要做的事情是什么</strong>。</p><p>后序遍历的代码框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">/*后序遍历代码的位置*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历出现的位置，<strong>如果当前节点要做的事需要通过左右子树的计算结果推导出来，就要用到后序遍历</strong>。</p><p>例如：leetcode 1373 题：二叉搜索子树的最大键值和。</p><p>输入一棵二叉树，这颗二叉树的子树可能包含二叉搜索树，返回它的节点值之和。</p><p>二叉树相关题目最核心的思路就是<strong>明确当前节点要做的事情是什么</strong></p><p>如果想计算子树中 BST 最大和，站在当前节点的视角，需要做什么？</p><ul><li>首先得知道左右子树是否是合法的 BST </li><li>然后左右子树加上本身节点还是不是合法的 BST 因为题目要计算最大的节点之和，如果左右子树加上自身还是一棵合法的 BST ，那么就需要知道这棵 BST 的所有结点值之和。方便进行比较。</li></ul><p><strong>根据以上三点，站在当前结点的视角，需要知道以下具体信息</strong></p><ul><li>左右子树是否是 BST</li><li>左子树的最大值和右子树的最小值</li><li>左右子树的结点值之和</li></ul><p>只有知道这几个值，才能满足题目的要求，想方法计算这些值</p><p>尝试用伪码写出算法的大致逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，记录 BST 最大节点之和</span></span><br><span class="line"><span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*遍历二叉树*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***** 前序遍历位置 *****/</span></span><br><span class="line">    <span class="comment">// 判断左右子树是不是 BST</span></span><br><span class="line">    <span class="keyword">if</span> (!isBST(root.left) || !isBST(root.right)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算左子树最大值和右子树最小值</span></span><br><span class="line">    <span class="keyword">int</span> leftMax = findMax(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMin = findMin(root.right);</span><br><span class="line">    <span class="comment">// 判断以 root 节点为根的树是不是 BST</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= leftMax || root.val &gt;= rightMin) &#123;</span><br><span class="line">        <span class="keyword">goto</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果条件都符合，计算当前 BST 的节点之和</span></span><br><span class="line">    <span class="keyword">int</span> leftSum = findSum(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightSum = findSum(root.right);</span><br><span class="line">    <span class="keyword">int</span> rootSum = leftSum + rightSum + root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算 BST 节点的最大和</span></span><br><span class="line">    <span class="keyword">this</span>.maxSum = Math.max(maxSum, rootSum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归遍历左右子树</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算以 root 为根的二叉树的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(TreeNode root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算以 root 为根的二叉树的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(TreeNode root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算以 root 为根的二叉树的节点和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSum</span><span class="params">(TreeNode root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断以 root 为根的二叉树是否是 BST</span></span><br><span class="line"><span class="function">boolean <span class="title">isBST</span><span class="params">(TreeNode root)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这个代码逻辑是不难理解的，代码在前序遍历的位置将之前的分析都实现了一遍。</p><p><strong>稍作分析就会发现，这几个辅助函数都是递归函数，都要遍历输入的二叉树，外加 reverse 函数本身的递归，这个解法的时间复杂度是非常高的。</strong></p><p>其实只要将前序遍历变成后序遍历，让 reverse 函数将辅助函数的事情顺便做了就好。</p><p>其它代码不变，让 reverse 函数做一些计算任务，返回一个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] traverse(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] left = traverse(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = traverse(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/********* 后序遍历位置 ***************/</span></span><br><span class="line">    <span class="comment">// 通过 left 和 right 推导返回值</span></span><br><span class="line">    <span class="comment">// 正确更新 maxSum 变量</span></span><br><span class="line">    <span class="comment">/************************************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>traverse(root)</code> 返回一个大小为 4 的 int 数组，暂且称它为 <code>res</code> ，其中：</p><ul><li><code>res[0]</code>记录以 root 为根的二叉树是否是 BST ，若为 1 则说明是 BST，若为 0 则说明不是 BST；</li><li><code>res[1]</code>记录以 root 为根的二叉树所有节点中的最小值</li><li><code>res[2]</code>记录以 root 为根的二叉树所有节点中的最大值</li><li><code>res[3]</code> 记录以 root 为根的二叉树所有节点值之和</li></ul><p>其实就是将之前的几个值放到了 <code>res</code> 数组中，<strong>最重要的是试图通过 <code>left</code> 和 <code>right</code> 正确推导出 res 数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] traverse(TreeNode root) &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归计算左右子树</span></span><br><span class="line">    <span class="keyword">int</span>[] left = traverse(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = traverse(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/******** 后序遍历位置 *********/</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 这个 if 在判断以 root 为根的二叉树是不是 BST</span></span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 以 root 为根的二叉树是 BST</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算以 root 为根的 BST 最小值</span></span><br><span class="line">        res[<span class="number">1</span>] = Math.min(left[<span class="number">1</span>], root.val);</span><br><span class="line">        <span class="comment">// 计算以 root 为根的 BST 最大值</span></span><br><span class="line">        res[<span class="number">2</span>] = Math.max(right[<span class="number">2</span>], root.val);</span><br><span class="line">        <span class="comment">// 计算以 root 为根的 BST 节点之和</span></span><br><span class="line">        res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">        <span class="comment">// 更新全局变量</span></span><br><span class="line">        maxSum = Math.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 以 root 为根的二叉树不是 BST</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 其它值没必要计算了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，这道题就解决了，traverse 函数在遍历二叉树的同时顺便将之前辅助函数做的事做了，避免了在递归函数中调用递归函数，时间复杂度只有 <code>O(N)</code></p><p>后序遍历在这种，当前节点要做的事需要左右子树的计算结果推导出来时，更加简洁、效率。</p><p>JS 实现代码（有问题）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSumBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> traverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左右子树是否是 BST</span></span><br><span class="line">        <span class="keyword">if</span> (!isBST(root.left) || !isBST(root.right)) &#123;</span><br><span class="line">            traverse(root.left);</span><br><span class="line">            traverse(root.right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左子树最大值和右子树最小值</span></span><br><span class="line">        <span class="keyword">const</span> leftMax = findMax(root.left);</span><br><span class="line">        <span class="keyword">const</span> rightMin = findMin(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= leftMax || root.val &gt;= rightMin) &#123;</span><br><span class="line">            traverse(root.left);</span><br><span class="line">            traverse(root.right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左右子树节点值</span></span><br><span class="line">        <span class="keyword">const</span> leftSum = sumNode(root.left);</span><br><span class="line">        <span class="keyword">const</span> rightSum = sumNode(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> sum = leftSum + rightSum + root.val;</span><br><span class="line">        maxSum = <span class="built_in">Math</span>.max(sum, maxSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBST2(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> isBST2 = <span class="function"><span class="keyword">function</span>(<span class="params">root, max, min</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isBST2(root.left, root, min) &amp;&amp; isBST2(root.right, max, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> findMax = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> max = <span class="built_in">Number</span>.MIN_VALUE;        </span><br><span class="line">        <span class="keyword">const</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">            max = <span class="built_in">Math</span>.max(max, root.val);</span><br><span class="line">            reverse(root.right);</span><br><span class="line">            reverse(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> findMin = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> min = <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">        <span class="keyword">const</span> traverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">            min = <span class="built_in">Math</span>.min(min, root.val);</span><br><span class="line">            traverse(root.left);</span><br><span class="line">            traverse(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> sumNode = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> traverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">            sum+= root.val;</span><br><span class="line">            traverse(root.left);</span><br><span class="line">            traverse(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSumBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxSum = <span class="built_in">Number</span>.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> traverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>, <span class="built_in">Number</span>.MIN_VALUE, <span class="built_in">Number</span>.MAX_VALUE, <span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> left = traverse(root.left);</span><br><span class="line">        <span class="keyword">const</span> right = traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 判断这个 root 为根节点的二叉树是不是 BST</span></span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] === <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] === <span class="number">1</span> &amp;&amp; left[<span class="number">1</span>] &lt; root.val &amp;&amp; right[<span class="number">2</span>] &gt; root.val) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = <span class="built_in">Math</span>.max(left[<span class="number">1</span>], root.val);</span><br><span class="line">            res[<span class="number">2</span>] = <span class="built_in">Math</span>.min(right[<span class="number">2</span>], root.val);</span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line"></span><br><span class="line">            maxSum = <span class="built_in">Math</span>.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSumBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> max=<span class="number">0</span>;</span><br><span class="line"> dfs(root)</span><br><span class="line"> <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 计算二叉树最大和</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 四元组分别表示当前子树为二叉搜索树、子树最小值、子树最大值，</span></span><br><span class="line">   <span class="comment">// 以及当前二叉搜索树数值求和</span></span><br><span class="line">   <span class="keyword">if</span>(!root) <span class="keyword">return</span> [<span class="literal">true</span>,<span class="literal">Infinity</span>,-<span class="literal">Infinity</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> left=dfs(root.left)</span><br><span class="line">   <span class="keyword">const</span> right=dfs(root.right)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> sum=<span class="number">0</span>,curMax,curMin;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 判断是否为二叉搜索树。当前节点比左子树最大值小或者比右子树最小值大都不是搜索树</span></span><br><span class="line">   <span class="keyword">if</span>(!left[<span class="number">0</span>]||!right[<span class="number">0</span>] </span><br><span class="line">      || root.val&lt;=left[<span class="number">2</span>]||root.val&gt;=right[<span class="number">1</span>])&#123;</span><br><span class="line">       <span class="keyword">return</span> [<span class="literal">false</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 包含当前节点的二叉搜索树中节点值范围[左子树最小值,右子树最大值]</span></span><br><span class="line">   curMin=root.left?left[<span class="number">1</span>]:root.val;</span><br><span class="line">   curMax=root.right?right[<span class="number">2</span>]:root.val;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 先计算临时和，再与当前最大和比较。类似数组求最大和的过程</span></span><br><span class="line">   sum+=left[<span class="number">3</span>]+right[<span class="number">3</span>]+root.val;</span><br><span class="line">   max=<span class="built_in">Math</span>.max(max,sum)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> [<span class="literal">true</span>,curMin,curMax,sum]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;后序遍历&quot;&gt;&lt;a href=&quot;#后序遍历&quot; class=&quot;headerlink&quot; title=&quot;后序遍历&quot;&gt;&lt;/a&gt;后序遍历&lt;/h2&gt;&lt;p&gt;二叉树的题目，无非就是前中后序遍历来回倒，但对于有的题目，不同的遍历顺序，复杂度不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>二分查找详解</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-05T14:23:39.218Z</published>
    <updated>2022-04-05T14:29:21.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。而且要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，可以灵活准确的写出正确的二分查找算法。</p><h3 id="一、二分查找框架"><a href="#一、二分查找框架" class="headerlink" title="一、二分查找框架"></a>一、二分查找框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析二分查找的一个技巧是：不要出现 else，而是将所有情况用 else if 写清楚，这样可以清楚的展现所有细节</strong>。</p><p>其中 <code>...</code> 出现的部分，就是可能出现细节问题的地方，当遇到一个二分查找的代码时，首先注意这些地方。</p><p>另外，计算 <code>mid</code> 时需要防止溢出，代码中 <code>left + (right - left)/2</code> 就和 <code>(left + right) /2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大直接相加导致溢出。</p><h3 id="二、寻找一个数（基本的二分搜索）"><a href="#二、寻找一个数（基本的二分搜索）" class="headerlink" title="二、寻找一个数（基本的二分搜索）"></a>二、寻找一个数（基本的二分搜索）</h3><p>搜索一个数，如果存在，返回其索引，否则返回 -1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. 为什么 while 循环的条件时 &lt;= ，而不是 &lt;</strong></p><p>因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。</p><p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭的区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。</p><p>这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。<strong>这个区间其实就是每次进行搜索的区间</strong>。</p><p>找到目标值的时候就可以终止搜索。但如果没找到，就需要 while 循环终止，返回 -1. 当<strong>搜索区间为空的时候应该终止</strong>，意味着没得找了，就等于没找到。</p><p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right+1</code>，写出区间的形式就是 <code>[right+1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有数字既大于3又小于等于2。所以这时候 while 循环终止是正确的，直接返回 -1 即可</p><p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[right, right]</code>，这时候区间非空，但此时 while 循环终止了。会漏了一个索引，这时候直接返回 -1 就是错误的。</p><p>如果非要用 <code>while(left&lt;right)</code>也可以，因为知道了原因，打个补丁就可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] === target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>2. 为什么 <code>left = mid + 1</code>, <code>right = mid - 1</code>? 有的代码是 <code>right = mid</code> 或者 <code>left = mid</code></strong></p><p>这也是二分查找的一个难点，但只要理解前面内容，就很容易判断。</p><p>刚刚明确了搜索区间的概念，且本算法的搜索区间两端都是闭的，即 <code>[left, right]</code>。那么当发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，应该去搜索哪里。<strong>因为 <code>mid</code> 已经搜索过，所以应该从搜索区间去除</strong>，搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code></p><p><strong>3. 该算法有什么缺陷</strong></p><p>这个算法存在局限性。</p><p>比如说给一个有序数组 <code>nums = [1, 2, 2, 2, 3]</code>，<code>target</code> 为2，此算法返回的索引是 2。但是如果想得到 <code>target</code> 的左侧边界，即索引 1，或者想得到 <code>target</code> 的右侧边界，即索引 3，这样的话，此算法是无法处理的。</p><p>这样的需求很常见，<strong>也许可以找到一个 target，然后向左或向右线性线性搜索，但是这样难以保证二分查找对数级的复杂度了</strong>。</p><p>后续的算法就讨论这两种二分查找的算法。</p><h3 id="二、寻找左侧边界的二分搜索"><a href="#二、寻找左侧边界的二分搜索" class="headerlink" title="二、寻找左侧边界的二分搜索"></a>二、寻找左侧边界的二分搜索</h3><p>以下是最常见的代码形式，其中的标记是需要注意的细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;<span class="comment">// 注意</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. 为什么 while 中是 &lt; 而不是 &lt;=</strong></p><p>用相同的方法分析，因为 <code>right = nums.length</code> 而不是 <code>nuums.length - 1</code>. 因此每次循环的搜索区间是 <code>[left, right)</code>左闭右开。</p><p><code>while(left&lt;right)</code>终止条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code>为空，所以可以正确终止。</p><p>PS：这里先要说一个搜索左右边界和上面这个算法的一个区别：<strong>刚才的 <code>right</code> 是 <code>nums.length-1</code> ， 而这里是 <code>nums.length</code>，使得搜索区间变成左闭右开</strong>。</p><p>因为对于搜索左右边界的二分查找，这种写法比较普遍。如果用两端都闭得写法反而更简单，后面会用一种两端都闭得写法将三种二分搜索统一起来。</p><p><strong>2. 为什么没有返回 -1 的操作，如果 <code>nums</code> 中不存在 <code>target</code> 值怎么办</strong></p><p>对于 <code>nums = [1, 2, 2, 2, 3], target = 2</code> 这个数组，算法会返回 1.这个 1 的含义可以这样解读：<code>nums</code> 中小于 2 的元素有 1 个。</p><p>比如对于有序数组 <code>nums = [2, 3, 5, 7], target = 1</code>，算法会返回 0，含义是：<code>nums</code>中小于 1 的元素有 0 个。</p><p>再比如 <code>nums = [2, 3, 5, 7], target=8</code>，算法会返回 4，含义是：<code>nums</code> 中小于 8 的元素有 4 个。</p><p>综上，函数的返回值（即 left 变量的值）取值区间是闭区间 <code>[0, nums.length]</code>，所以简单的提炼两行代码就能在正确的时候 <code>return -1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// target 比所有数都大</span></span><br><span class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 类似之前算法的处理方式</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>3. 为什么 left = mid + 1, right = mid，和之前的算法不一样</strong></p><p>这是因为搜索区间是 <code>[left, right)</code>左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉mid 分割成两个区间，即 <code>[left, mid)</code>或 <code>[mid+1, right)</code></p><p><strong>4. 为什么该算法能够搜索左侧边界</strong></p><p>关键在于对 <code>nums[mid] == target</code>, 这种情况的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">    right = mid;</span><br></pre></td></tr></table></figure><p>可见找到 target 时不立即返回，而是缩小搜索区间的上界 <code>right</code>，在区间 <code>[left, mid)</code>中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p><p><strong>5. 为什么返回 left 而不是 right</strong></p><p>都是一样的，因为 while 的终止条件时 <code>left == right</code></p><p><strong>6. 能不能想办法将 <code>right</code> 变成 <code>nums.length - 1</code>， 也就是继续使用两边都闭得搜索区间，这样就可以和第一种二分搜索某种程度上统一起来</strong></p><p>只要明白搜索区间的概念，就能有效避免漏掉元素。</p><p>如果要让搜索区间两端都闭， <code>right</code>应该初始化为 <code>nums.length - 1</code>，while 的终止条件时 <code>left == right+1</code>，也就是其中应该用 <code>&lt;=</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// if else</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为搜索区间时两端都闭的，且现在是搜索左侧边界，所以 <code>left</code> 和 <code>right</code> 的更新逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    <span class="comment">// 收缩右侧边界</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">    <span class="comment">// 搜索区间变为 [left, mid - 1]</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 while 的退出条件是 <code>left == right + 1</code>，所以当 <code>target</code> 比 <code>numms</code> 中所有元素都大时，会存在索引越界。</p><p>所以最后返回结果的代码应该检查越界情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure><p>至此，完整的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相似题目：</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> solution = <span class="function"><span class="keyword">function</span>(<span class="params">isBadVersion</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;integer&#125; n Total versions</span></span><br><span class="line"><span class="comment">     * @return &#123;integer&#125; The first bad version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">const</span> mid = left + <span class="built_in">Math</span>.floor((right - left)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; n || !isBadVersion(left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="四、寻找右侧边界的二分查找"><a href="#四、寻找右侧边界的二分查找" class="headerlink" title="四、寻找右侧边界的二分查找"></a>四、寻找右侧边界的二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="comment">// if (left &gt;= nums.length || nums[left] != target)</span></span><br><span class="line">    <span class="comment">//    return -1;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里改为检查 right 越界情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因为收紧左侧边界时必须 left = mid + 1，所以最后无论返回 left 还是 right，唏嘘减一</strong></p><h4 id="PS：为什么查左侧边界要考虑-left-越界，右侧边界要考虑-right-越界？"><a href="#PS：为什么查左侧边界要考虑-left-越界，右侧边界要考虑-right-越界？" class="headerlink" title="PS：为什么查左侧边界要考虑 left 越界，右侧边界要考虑 right 越界？"></a>PS：为什么查左侧边界要考虑 left 越界，右侧边界要考虑 right 越界？</h4><h3 id="四、逻辑统一"><a href="#四、逻辑统一" class="headerlink" title="四、逻辑统一"></a>四、逻辑统一</h3><p>梳理一下这些细节差异的因果逻辑</p><p><strong>第一个，最基本的二分查找算法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">因为初始化 right = nums.length - 1</span><br><span class="line">所以决定了搜索区间是 [left, right]</span><br><span class="line">所以决定了 while(left &lt;= right)</span><br><span class="line">同时也决定了 left = mid + 1, right = mid - 1</span><br><span class="line"></span><br><span class="line">只需要找到一个 target 的索引</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br></pre></td></tr></table></figure><p><strong>第二个，寻找左侧边界的二分查找</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">因为初始化 right = nums.length</span><br><span class="line">所以决定了搜索区间时 [left, right)</span><br><span class="line">所以决定了 while(left &lt; right)</span><br><span class="line">同时也决定了 left = mid + 1, right = mid</span><br><span class="line"></span><br><span class="line">因为需要找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure><p>第三个，寻找右侧边界的二分查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">因为初始化 right = nums.length</span><br><span class="line">所以决定了搜索区间时 [left, right)</span><br><span class="line">所以决定了 while(left &lt; right)</span><br><span class="line">同时也决定了 left = mid + 1, right = mid</span><br><span class="line"></span><br><span class="line">因为需要找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而是要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 left = mid + 1</span><br><span class="line">所以最后无论返回 left 还是 right，必须减一</span><br></pre></td></tr></table></figure><p>对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的搜索区间。<strong>还根据逻辑将搜索区间全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后检查 left 越界情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后检查 right 越界情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过本文，可以得到：</p><ol><li>分析二分查找代码时，不要使用 else，全部展开成 else if 便于理解</li><li>注意搜索区间和 while 的终止条件，如果存在漏掉的元素，记得在最后检查</li><li>如果需定义左闭右开的搜索区间搜索左右边界，只要在 <code>nums[mid] == target</code> 时做修改即可，搜索右侧时需要减一</li><li>如果将搜索区间全部统一成两端都闭，好记，只要稍改 <code>nums[mid] == target</code>条件处的代码和返回逻辑即可。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h2&gt;&lt;p&gt;探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。而且要深入细节，比如不等号是否应该带等号，mid 是否</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树（一）</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-04-05T14:23:39.216Z</published>
    <updated>2022-04-05T14:28:51.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树（一）"><a href="#二叉搜索树（一）" class="headerlink" title="二叉搜索树（一）"></a>二叉搜索树（一）</h2><p>二叉搜索树（Binary Search Tree） ，简称  BST 。</p><p>BST 的特性：</p><ol><li>对于 BST 每一个节点 node ，左子树节点的值都比 node 的值要小，右子树节点的值都比 node 的值大。</li><li>对于 BST 每一个节点 node，它的左侧子树和右侧子树都是 BST。</li></ol><p>二叉搜索树并不复杂，但是很多数据结构都是基于 BST 的。比如 AVL 树，红黑树等等。拥有自平衡性质，可以提供您 log N 级别的增删改查效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。</p><p><b>从做算法题的角度来看 BST ，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）</b></p><p>也就是说，如果输入一棵 BST ，以下代码可以将 BST 中每个节点的值升序打印出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">traverse(root.left);</span><br><span class="line"><span class="comment">// 中序遍历代码位置</span></span><br><span class="line">print(root.val);</span><br><span class="line">traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这个性质，我们可以做两道算法题</p><h4 id="1-寻找第-K-小的元素"><a href="#1-寻找第-K-小的元素" class="headerlink" title="1. 寻找第 K 小的元素"></a>1. 寻找第 K 小的元素</h4><p>leetcode 230题：</p><p>给定一个二叉搜索树，编写一个函数来查找其中第 k 个最小的元素。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k=3</span><br><span class="line">5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \</span><br><span class="line">2   4</span><br><span class="line">   /</span><br><span class="line">  1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>思路就是利用 BST 的中序遍历是一个升序的过程来找到第 k 个元素。可以直接写出代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        kthSmallest(root.left, k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            result = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        kthSmallest(root.right, k);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个解法并不是最高效的解法，仅仅只是适用于这道题。</p><p>每次寻找第 k 小的元素都要中序遍历一次，最坏的时间复杂度是 O(N)，N 是 BST 的节点个数。</p><p>BST 的性质很强，像红黑树这种改良的自平衡 BST ，增删改查都是 O(log N) 的复杂度，算一个第 k 小元素，时间复杂度竟然要 O(N)，这就有些低效了。</p><p>所以说，计算第 k 小元素，最好的算法肯定也是对数级别的复杂度，不过这个依赖 BST 节点记录的信息有多少。</p><p>BST 高效的原因是：<strong>所有节点都可以通过对比自身的值判断去左子树还是右子树搜索目标值，从而避免全树的遍历，达到对数级复杂度</strong>。</p><p>回到这个问题，想找到第 k 小的元素，如果想达到对数级复杂度，关键也在于每个节点得知道他自己排第几。</p><p>比如，当前节点知道自己排名 m ，我们可以比较 m 和 k 的大小：</p><ul><li>如果 m == k，显然就是找到了第 k 个元素，返回当前节点就行了；</li><li>如果 k &lt; m，说明排名第 k 的元素在左子树，去左子树搜索；</li><li>如果 k &gt; m，说明排名第 k 的元素在右子树，去右子树搜索；</li></ul><p>这样就可以将时间复杂度降到 O(log N) 了。</p><p>如何让每个节点知道自己的排名呢？</p><p>这就需要在二叉树节点中维护额外信息。<strong>每个节点需要记录，以自己为根的这颗二叉树有多少个节点</strong>。</p><p>TreeNode 中的字段应该如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="comment">// 以该节点为根的树的节点总数</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 size 字段，外加 BST 左小右大的性质，对每个节点 node 可以通过 <code>node.left.size</code> 得到 node 的排名，从而做到对数级算法。</p><h4 id="2-BST-转换累加树"><a href="#2-BST-转换累加树" class="headerlink" title="2. BST 转换累加树"></a>2. BST 转换累加树</h4><p>leetcode 538 和 1038 题：</p><p>给出二叉搜索树的根节点，该树的节点值各不相同，将其转换为累加树，使每个节点 node 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>即：累加树的每个节点值为所有值中大于等于该点值得总和。</p><p>签名函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeNode convertBST(TreeNode root);</span><br></pre></td></tr></table></figure><p>按照二叉树得通用思路，需要考虑每个节点应该做什么，但是这道题很难想到什么思路。</p><p>BST 是左小右大的，既然累加和是计算大于等于当前值的所有元素之和，那么每个节点都去计算右子树的和，不就行了。但是这是不行的，因为父节点也可能比他大。</p><p>利用 BST 的中序遍历特性。BST 的中序遍历代码可以升序打印节点的值。如果想降序，只需要将递归的顺序改一下即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 先递归遍历右子树</span></span><br><span class="line">traverse(root.right);</span><br><span class="line"><span class="comment">// 中序遍历代码位置</span></span><br><span class="line">print(root.val);</span><br><span class="line"><span class="comment">// 后递归遍历左子树</span></span><br><span class="line">traverse(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码可以从大到小降序打印 BST 节点的值，如果维护一个外部变量 sum，然后将 sum 赋值给 BST 中的每一个节点，就将 BSt 转化成累加树了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录累加和</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    sum += root.val;</span><br><span class="line">    root.val = sum;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心还是 BST 的中序遍历特性，只不过修改了递归的顺序，降序遍历 BST 的元素值，从而契合题目累加树的要求。</p><p><strong>总结：</strong>BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉搜索树（一）&quot;&gt;&lt;a href=&quot;#二叉搜索树（一）&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树（一）&quot;&gt;&lt;/a&gt;二叉搜索树（一）&lt;/h2&gt;&lt;p&gt;二叉搜索树（Binary Search Tree） ，简称  BST 。&lt;/p&gt;
&lt;p&gt;BS</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树（三）</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-04-05T14:23:39.213Z</published>
    <updated>2022-04-05T14:28:39.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树（三）"><a href="#二叉搜索树（三）" class="headerlink" title="二叉搜索树（三）"></a>二叉搜索树（三）</h2><p>之前两篇，一篇是中序遍历对 BST 的重要意义，另一篇是 BST 的基本操作。</p><p>两道题，如何计算所有合法 BST。</p><h3 id="一、不同的二叉搜索树"><a href="#一、不同的二叉搜索树" class="headerlink" title="一、不同的二叉搜索树"></a>一、不同的二叉搜索树</h3><p>给一个整数 n ，求给由 n 个节点组成且节点值从 1 到 n 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意得二叉搜索树得种数。即，存储 <code>{1,2,3,...,n}</code> 这些值共有多少种不同的 BST 结构。</p><p>签名函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>比如输入 n=3 ，算法返回 5，因为共有 5 种不同的 BST 结构存储 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = 3 时有如下 5 种不同的 BST 结果：</span><br><span class="line"> 1              3      3         2       1</span><br><span class="line">  \            /      /         / \       \</span><br><span class="line">   3          2      1         1   3       2</span><br><span class="line">  /          /        \                     \</span><br><span class="line"> 2          1          2                     3</span><br></pre></td></tr></table></figure><p>这就是一个正宗的穷举问题，如何正确的穷举合法 BST 的数量。</p><p>举个例子，比如给算法输入 n = 5, 即用 {1, 2, 3, 4 5} 这些数字去构造 BST。每个数字都可以作为根节点，</p><p>比如固定 3 作为根节点，这个前提下，根据 BST 特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。所以固定 3 作为根节点，左子树节点就是 {1, 2} 的组合，右子树就是 {4, 5} 的组合。<strong>左子树和右子树组合数的乘积</strong>就是 3 作为根节点时的 BST 个数。</p><p>如何让算法进行计算，借助递归即可，可以写这样一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：闭区间 [lo, hi] 的数字能组成 count(lo, hi) 种 BST</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>;</span><br></pre></td></tr></table></figure><p>根据这个函数的定义，可以写出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算区间 [lo, hi] 组成的 BST 个数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="comment">// base case</span></span><br><span class="line"><span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=lo; i&lt;=hi; i++) &#123;</span><br><span class="line"><span class="comment">// i 的值作为根节点 root</span></span><br><span class="line"><span class="keyword">int</span> left = count(lo, i-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> right = count(i+<span class="number">1</span>, hi);</span><br><span class="line"><span class="comment">// 左右子树的组合数的乘积时 BST 的总数</span></span><br><span class="line">res += left*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：base case，显然当 lo &gt; hi 闭区间 [lo, hi] 肯定是个空区间，也就是对应的空节点 null，虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0。</p><p>这种，题目的要求已经实现了，但是肯定存在重叠子问题。</p><p>动态规划相关的问题种消除重叠子问题的方法，就是加一个备忘录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line"><span class="keyword">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 备忘录的值初始化为0</span></span><br><span class="line">memo = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 查备忘录</span></span><br><span class="line"><span class="keyword">if</span> (memo[lo][hi] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> memo[lo][hi];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i&lt;=hi; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> left = count(lo, i-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> right = count(i+<span class="number">1</span>, hi);</span><br><span class="line">res += left*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将结果存入备忘录</span></span><br><span class="line">memo[lo][hi] = res;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，这题就完全解决了。</p><p>一个进阶的题目，不止计算有几个不同的 BST，而是要构建出所有合法的 BST，如何实现。</p><h3 id="二、不同的二叉树-Ⅱ"><a href="#二、不同的二叉树-Ⅱ" class="headerlink" title="二、不同的二叉树 Ⅱ"></a>二、不同的二叉树 Ⅱ</h3><p>构建所有 BST，签名函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;TreeNode&gt; <span class="title">generateTree</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>比如说输入 n=3 ，算法返回一个列表，列表中存储着五颗 BST 的根节点。</p><p>明白了上道题构造合法 BST 的方法，这题思路也是一样：</p><ol><li>穷举 root 节点的所有可能</li><li>递归构造出左右子树的所有合法 BST</li><li>给 root 节点穷举所有左右子树的组合</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">// 构造闭区间 [1, n] 组成的 BST</span></span><br><span class="line"><span class="keyword">return</span> build(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造闭区间 [lo, hi] 组成的 BST */</span></span><br><span class="line"><span class="function">List&lt;TreeNode&gt; <span class="title">build</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">res.add(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 穷举 root 节点的所有可能性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=lo; i&lt;=hi; i++) &#123;</span><br><span class="line"><span class="comment">// 2. 递归构造出左右子树的所有合法 BST</span></span><br><span class="line">List&lt;TreeNode&gt; leftTree = build(lo, i-<span class="number">1</span>);</span><br><span class="line">List&lt;TreeNode&gt; rightTree = build(i+<span class="number">1</span>, hi);</span><br><span class="line"><span class="comment">// 3. 给 root 节点穷举所有左右子树的组合</span></span><br><span class="line"><span class="keyword">for</span> (TreeNode left : leftTree) &#123;</span><br><span class="line"><span class="keyword">for</span> (TreeNode right : rightTree) &#123;</span><br><span class="line"><span class="comment">// i 作为根节点 root 的值</span></span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">root.left = left;</span><br><span class="line">root.right = right;</span><br><span class="line">res.add(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉搜索树（三）&quot;&gt;&lt;a href=&quot;#二叉搜索树（三）&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树（三）&quot;&gt;&lt;/a&gt;二叉搜索树（三）&lt;/h2&gt;&lt;p&gt;之前两篇，一篇是中序遍历对 BST 的重要意义，另一篇是 BST 的基本操作。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树（二）</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-04-05T14:23:39.207Z</published>
    <updated>2022-04-05T14:28:24.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树（二）"><a href="#二叉搜索树（二）" class="headerlink" title="二叉搜索树（二）"></a>二叉搜索树（二）</h2><p>之前主要是利用二叉搜索树的中序遍历的有序性来解决问题，本文记录实现 BST 的基础操作：判断 BST 的合法性、增、删、查。</p><h3 id="一、判断-BST-的合法性"><a href="#一、判断-BST-的合法性" class="headerlink" title="一、判断 BST 的合法性"></a>一、判断 BST 的合法性</h3><p>按照之前的思路，每个节点自己要做的事就是比较自己和左右孩子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.val &lt;= root.left.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; root.val &gt;= root.right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isValidBST(root.left) &amp;&amp; isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样写是有问题的，BST 的每个节点应该要小于右边子树的所有节点。但是，这算法会出现根节点的右孩子节点的左孩子节点小于根节点的情况，这不符合二叉搜索树的定义，但是该算法会把它判定为合法的 BST。</p><p>出问题的原因在于，<strong>对于每一个节点 root，代码检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，root 的整个左子树都要小于 <code>root.val</code> ，整个右子树都要大于 <code>root.val</code></strong> 。</p><p>对于某一个节点 root，他只能管得了自己的左右子节点，怎么把 root 的约束传递给左右子树。</p><p>通过<strong>使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line"><span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span></span><br><span class="line"><span class="keyword">return</span> isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、在-BST-中搜索一个数"><a href="#二、在-BST-中搜索一个数" class="headerlink" title="二、在 BST 中搜索一个数"></a>二、在 BST 中搜索一个数</h3><p>如果是在二叉树中寻找元素，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (root.val == taget) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 当前节点没有找到，就递归的去左右子树中寻找</span></span><br><span class="line"><span class="keyword">return</span> isInBST(root.left, target) || isInBST(root.right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码相当于穷举了所有节点，适用于所有普通二叉树，但是如何充分利用 BST 左大右小的特性。</p><p>不需要递归的搜索两边，类似二分查找思想，根据 <code>target</code> 和 <code>root.val</code> 的大小比较，就能排除一边。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (root.val == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (root.val &gt; target) <span class="keyword">return</span> isInBST(root.left, target);</span><br><span class="line"><span class="keyword">if</span> (root.val &lt; target) <span class="keyword">return</span> isInBST(root.right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对原始框架进行改造，抽象出一套<strong>针对 BST 的遍历框架</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span> <span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root.val == target) <span class="comment">// 找到目标后 do something</span></span><br><span class="line"><span class="keyword">if</span> (root.val &gt; target) BST(root.left, target);</span><br><span class="line"><span class="keyword">if</span> (root.val &lt; target) BST(root.right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、在-BST-中插入一个数"><a href="#三、在-BST-中插入一个数" class="headerlink" title="三、在 BST 中插入一个数"></a>三、在 BST 中插入一个数</h3><p>对数据结构的操作无非遍历 + 访问，遍历就是找，访问就是改。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。</p><p><strong>一旦涉及改，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 找到空位置插入新节点</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"><span class="keyword">if</span> (root.val &lt; val) </span><br><span class="line">root.right = insertIntoBST(root.right, val);</span><br><span class="line"><span class="keyword">if</span> (root.val &gt; val)</span><br><span class="line">root.left = insertIntoBST(root.left, val);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、在-BST-中删除一个数"><a href="#四、在-BST-中删除一个数" class="headerlink" title="四、在 BST 中删除一个数"></a>四、在 BST 中删除一个数</h3><p>这个问题稍微服务，跟插入操作类似，先找再改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line"><span class="comment">// 找到，进行删除操作</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line"><span class="comment">// 去左子树中进行查找</span></span><br><span class="line">root.left = deleteNode(root.left, key);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line"><span class="comment">// 去右子树中进行查找</span></span><br><span class="line">root.right = deleteNode(root.right, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到目标节点后，如何删除这个节点是个难点。因为删除节点的同时，不能破坏 BST 的性质。</p><p>比如，有三种情况：</p><ul><li><p><strong>情况一</strong>：A 恰好是末端节点，两个子节点均为空，那么可以直接删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>情况二</strong>：A 只有一个非空子节点，那么他要让这个孩子接替自己的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line"><span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br></pre></td></tr></table></figure></li><li><p><strong>情况三</strong>：A 有两个子节点，这就比较复杂了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点或右子树中最小的节点来接替自己</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">TreeNode minNode = getMin(root.right);</span><br><span class="line"><span class="comment">// 将 root 改成 minNode</span></span><br><span class="line">root.val = minNode.val;</span><br><span class="line"><span class="comment">// 删除 minNode</span></span><br><span class="line">root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>整合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line"><span class="comment">// 这两个 if 将情况1和情况2都正确处理了</span></span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line"><span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line"><span class="comment">// 处理情况3</span></span><br><span class="line">TreeNode minNode = getMin(root.right);</span><br><span class="line">root.val = minNode.val;</span><br><span class="line">root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">root.left = deleteNode(root.left, key);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">root.right = deleteNode(root.right, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">getMin</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">    <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作就完成了。当然，这个删除操作并不完美，因为我们一般不会通过 <code>root.val = minNode.val</code> 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 <code>root</code> 和 <code>minNode</code> 两个节点。</p><p>因为具体应用中，val 域可能会是一个复杂的数据结构，修改起来非常麻烦；而链表操作无非改一改指针，不会去碰内部数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结以下几个技巧：</p><ol><li><p>如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p></li><li><p>在二叉树递归框架之上，扩展出一套 BST 代码框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root.val == target) <span class="comment">// 找到目标，做点什么</span></span><br><span class="line"><span class="keyword">if</span> (root.val &lt; target) BST(root.right, target);</span><br><span class="line"><span class="keyword">if</span> (root.val &gt; target) BST(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据代码框架掌握了 BST 的增删改查操作。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉搜索树（二）&quot;&gt;&lt;a href=&quot;#二叉搜索树（二）&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树（二）&quot;&gt;&lt;/a&gt;二叉搜索树（二）&lt;/h2&gt;&lt;p&gt;之前主要是利用二叉搜索树的中序遍历的有序性来解决问题，本文记录实现 BST 的基础操作：判断</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树题目</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A0%E6%A0%91%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A0%E6%A0%91%E9%A2%98%E7%9B%AE/</id>
    <published>2022-04-05T14:23:39.202Z</published>
    <updated>2022-04-05T14:27:59.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树题目"><a href="#二叉搜索树题目" class="headerlink" title="二叉搜索树题目"></a>二叉搜索树题目</h2><h4 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h4><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p><p><strong>思路1：</strong>可以先进行遍历，得到一个数组序列，找出错误的位置，再重新遍历二叉树进行恢复。空间复杂度为 <code>O(N)</code></p><p><strong>思路2：</strong>利用一个前序指针和当前节点进行比较，用 x 保存第一次出错的位置，y 更新迭代最后出错的位置，遍历完成后，将错误的两个位置的值进行互换。比思路1节省空间复杂度。空间复杂度为 <code>O(1)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> recoverTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre;</span><br><span class="line">    <span class="keyword">let</span> x, y;</span><br><span class="line">    <span class="keyword">const</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        reverse(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre &amp;&amp; pre.val &gt; root.val) &#123;</span><br><span class="line">            y = root;</span><br><span class="line">            <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">                x = pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        reverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(root);</span><br><span class="line">    <span class="keyword">const</span> temp = x.val;</span><br><span class="line">    x.val = y.val;</span><br><span class="line">    y.val = temp;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉搜索树题目&quot;&gt;&lt;a href=&quot;#二叉搜索树题目&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树题目&quot;&gt;&lt;/a&gt;二叉搜索树题目&lt;/h2&gt;&lt;h4 id=&quot;恢复二叉搜索树&quot;&gt;&lt;a href=&quot;#恢复二叉搜索树&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树基本操作</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2022-04-05T14:23:39.199Z</published>
    <updated>2022-04-05T14:27:42.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h2><h3 id="完全二叉树的一些公式"><a href="#完全二叉树的一些公式" class="headerlink" title="完全二叉树的一些公式"></a>完全二叉树的一些公式</h3><ol><li>第 n 层的节点数最多为 <code>2^n</code>个节点</li><li>n 层二叉树最多有 <code>2^0 + ... + 2^n = 2^n+1 - 1</code> 个节点</li><li>最后一个非叶子节点 length/2</li><li>一个节点的孩子节点：2n、2n+1</li></ol><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>插入、遍历、深度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node.prototype = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree.prototype = &#123;</span><br><span class="line">    insert: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="keyword">new</span> Node(data, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.root) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = node;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">var</span> parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; parent.data) &#123;</span><br><span class="line">                current = current.left;</span><br><span class="line">                <span class="keyword">if</span> (!current) &#123;</span><br><span class="line">                    parent.left = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.right;</span><br><span class="line">                <span class="keyword">if</span> (!current) &#123;</span><br><span class="line">                    parent.right = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    preOrder: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node) &#123;</span><br><span class="line">            node.show();</span><br><span class="line">            preOrder(node.left);</span><br><span class="line">            preOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    middleOrder: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            middleOrder(node.left);</span><br><span class="line">            node.show();</span><br><span class="line">            middleOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    postOrder: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            postOrder(node.left);</span><br><span class="line">            postOrder(node.right);</span><br><span class="line">            node.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    getMin: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!current.left) &#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    getMax: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!current.right) &#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    getDeep: <span class="function"><span class="keyword">function</span>(<span class="params">node, deep</span>) </span>&#123;</span><br><span class="line">        deep = deep || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> deep;</span><br><span class="line">        &#125;</span><br><span class="line">        deep++;</span><br><span class="line">        <span class="keyword">var</span> dleft = <span class="keyword">this</span>.getDeep(node.left, deep);</span><br><span class="line">        <span class="keyword">var</span> dright = <span class="keyword">this</span>.getDeep(node.right, deep);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(dleft, dright);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Tree();</span><br><span class="line">t.insert(<span class="number">3</span>);</span><br><span class="line">t.insert(<span class="number">8</span>);</span><br><span class="line">t.insert(<span class="number">1</span>);</span><br><span class="line">t.insert(<span class="number">2</span>);</span><br><span class="line">t.insert(<span class="number">5</span>);</span><br><span class="line">t.insert(<span class="number">7</span>);</span><br><span class="line">t.insert(<span class="number">6</span>);</span><br><span class="line">t.insert(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(t);</span><br><span class="line"><span class="built_in">console</span>.log(t.getMin(), t.getMax());</span><br><span class="line"><span class="built_in">console</span>.log(t.getDeep(t.root, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(t.getNode(<span class="number">5</span>, t.root));</span><br></pre></td></tr></table></figure><h3 id="树查找"><a href="#树查找" class="headerlink" title="树查找"></a>树查找</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getNode: <span class="function"><span class="keyword">function</span>(<span class="params">data, node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data === node.data) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; node.data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.getNode(data, node.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; node.data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.getNode(data, node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找的条件是必须是有序的线性表</p><p>和线性表的中点值进行比较，如果小就继续在小的序列中查找，如此递归直到找到相同的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">data, arr,start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((end + start)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (data == arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(data, arr, start, mid<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(data, arr, mid+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树的基本操作&quot;&gt;&lt;a href=&quot;#二叉树的基本操作&quot; class=&quot;headerlink&quot; title=&quot;二叉树的基本操作&quot;&gt;&lt;/a&gt;二叉树的基本操作&lt;/h2&gt;&lt;h3 id=&quot;完全二叉树的一些公式&quot;&gt;&lt;a href=&quot;#完全二叉树的一些公式&quot; class=&quot;</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树概览</title>
    <link href="http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2022/04/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%A6%82%E8%A7%88/</id>
    <published>2022-04-05T14:23:39.194Z</published>
    <updated>2022-04-05T14:27:24.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树系列"><a href="#二叉树系列" class="headerlink" title="二叉树系列"></a>二叉树系列</h2><p>树是用来模拟具有树状结构性质的数据集合。根据性质可分为很多种类，只要了解二叉树这种结构就足够了，它是树中最简单、应用最广泛的种类。</p><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>重点中的重点，同时掌握递归和非递归版本。递归版本很容易，但真正考验基本功的是非递归版本</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul><p>递归遍历框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序遍历代码</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序遍历代码</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前序遍历代码"><a href="#前序遍历代码" class="headerlink" title="前序遍历代码"></a>前序遍历代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preorderTraversal = <span class="function">(<span class="params">root, array=[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> array;</span><br><span class="line">    array.push(root.val);</span><br><span class="line">    preorderTraversal(root.left);</span><br><span class="line">    preorderTraversal(root.right);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归实现：</p><ul><li><p>取根节点为目标节点，开始遍历</p></li><li><p>访问目标节点</p></li><li><p>左孩子入栈，直至左孩子为空的节点</p></li><li><p>节点出栈，以右孩子为目标节点，再次执行2，3，4</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preorderTraversal = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> current = root;</span><br><span class="line">    <span class="keyword">while</span>(current || stack.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            result.push(current.val);</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="中序遍历代码"><a href="#中序遍历代码" class="headerlink" title="中序遍历代码"></a>中序遍历代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderTraversal = (root, array=[]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        inorderTraversal(root.left, array);</span><br><span class="line">        array.push(root.val);</span><br><span class="line">        inorderTraversal(root.right, array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归实现：</p><ul><li><p>取根节点为目标节点，开始遍历</p></li><li><p>左孩子入栈，直至左孩子为空</p></li><li><p>节点出栈，访问该节点</p></li><li><p>以右孩子为目标节点，再次执行 2，3，4</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderTraversal = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> current = root;</span><br><span class="line">    <span class="keyword">while</span>(current || stack.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        result.push(current.val);</span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="后序遍历代码"><a href="#后序遍历代码" class="headerlink" title="后序遍历代码"></a>后序遍历代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postorderTraversal = (root, array=[]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        postorderTraversal(root.left, array);</span><br><span class="line">        postorderTraversal(root.right, array);</span><br><span class="line">        array.push(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归遍历：</p><ul><li><p>以根节点为目标节点，开始遍历</p></li><li><p>左孩子入栈，直至左孩子为空的节点</p></li><li><p>栈顶节点的右孩子为空或被访问过，则节点出栈并访问，将节点标记为已访问</p></li><li><p>栈节点的右孩子不为空且未被访问，以右孩子为目标节点再执行2，3，4</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postorderTraversal = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> last = <span class="literal">null</span>; <span class="comment">// 标记上一个访问的节点</span></span><br><span class="line">    <span class="keyword">let</span> current = root;</span><br><span class="line">    <span class="keyword">while</span>(current || stack.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(current) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = stack[stack.length<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!current.right || current.right == last) &#123;</span><br><span class="line">            current = stack.pop();</span><br><span class="line">            result.push(current.val);</span><br><span class="line">            last = current;</span><br><span class="line">            current = <span class="literal">null</span>; <span class="comment">// 继续弹栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>给一个二叉树，返回其按 <strong>层序遍历</strong> 得到的节点值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leverOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentLevelLength = queue.length;</span><br><span class="line">        <span class="keyword">const</span> level = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;currentLevelLength; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = q.shift();</span><br><span class="line">            level.push(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left) queue.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right) queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(level.slice())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> q = [];</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (q.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentLevelSize = q.length;</span><br><span class="line">        ret.push([]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = q.shift();</span><br><span class="line">            ret[ret.length - <span class="number">1</span>].push(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left) q.push(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right) q.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4><p>根据前序遍历和中序遍历或者中序遍历和后序遍历的特点重建二叉树</p><p><strong>思路：</strong></p><ul><li>前序遍历：根节点 + 左子树前序遍历 + 右子树前序遍历</li><li>中序遍历： 左子树中序遍历 + 根节点 + 右子树中序遍历</li><li>后序遍历：左子树后序遍历 + 右子树后序遍历 + 根节点</li></ul><p>根据以上规律，通过前序遍历和中序遍历构造二叉树：</p><ul><li>前序遍历找到根节点 root</li><li>找到 root 在中序遍历中的位置，从而得到左子树和右子树长度</li><li>截取左子树的中序遍历、右子树的中序遍历</li><li>截取左子树的前序遍历、右子树的前序遍历</li><li>递归重建二叉树</li></ul><p>根据前序和中序构建二叉树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildBinaryTree = <span class="function">(<span class="params">pre, vin</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pre === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (pre === <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> index;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;vin.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[<span class="number">0</span>] === vin[i]) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> pre_left = pre.slice(<span class="number">1</span>, index+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> pre_right = pre.slice(index+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> in_left = vin.slice(<span class="number">0</span>, index);</span><br><span class="line">    <span class="keyword">const</span> in_right = vin.slice(index+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    node.left = buildBinaryTree(pre_left, in_left);</span><br><span class="line">    node.right = buildBinaryTree(pre_right, in_right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的对称性"><a href="#二叉树的对称性" class="headerlink" title="二叉树的对称性"></a>二叉树的对称性</h3><h4 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h4><p>实现一个函数判断二叉树是不是对称的。</p><p>借助辅助函数，将根结点传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSymmetrical = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetricalTree(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isSymmetricalTree = <span class="function">(<span class="params">node1, node2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node1 &amp;&amp; !node2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!node1 || !node2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node1.val != node2.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSymmetricalTree(node1.left, node2.right) &amp;&amp; isSymmetricalTree(node1.right, node2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树镜像"><a href="#二叉树镜像" class="headerlink" title="二叉树镜像"></a>二叉树镜像</h4><p>操作给定的二叉树，将其变换为源二叉树的镜像</p><p>递归交换所有节点左右节点的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mirror = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirror(root.left);</span><br><span class="line">        mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树是特殊的二叉树，考察二叉搜索树的题目一般都是考察二叉搜索树的特性。</p><ul><li>任意节点的左子树不为空，则它的左子树上所有的结点的值均小于它的根结点的值。</li><li>任意节点的右子树不为空，则它的右子树上所有的结点的值均大于它的根节点的值。</li><li>任意结点的左右子树也是一颗二叉搜索树。</li></ul><p>二叉搜索树的中序遍历是一个排序后的结点</p><h4 id="二叉搜索树的第-k-个结点"><a href="#二叉搜索树的第-k-个结点" class="headerlink" title="二叉搜索树的第 k 个结点"></a>二叉搜索树的第 k 个结点</h4><p>给定一颗二叉搜索树，请找出其中第 k 小的结点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">const</span> kthNode = <span class="function">(<span class="params">root, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    kthNode(root.left, k);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count === k) &#123;</span><br><span class="line">        result = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    kthNode(root.right, k);</span><br><span class="line">    <span class="keyword">return</span> resultl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>二叉树的深度为根节点到最远叶子结点的最长路径上的结点数。</p><p><strong>平衡二叉树：左右子树深度之差大于1</strong></p><h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p>最大深度就是从根节点到最远叶子结点的最长路径上的结点数量。</p><p>思路：深度优先遍历 + 分治；<strong>一颗二叉树的最大深度等于左子树深度和右子树深度最大值 + 1</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeDepth = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(treeDepth(root.left), treeDepth(root.right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h4><p>最小深度是从根节点到最近叶子节点的最短路径上的节点</p><p>思路：</p><ul><li>左右子树都不为空：左子树深度和右子树最小深度的最小值 + 1</li><li>左树为空：右子树最小深度的最小值 + 1</li><li>右树为空：左子树最小深度的最小值 + 1</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> minDepth = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root.left) <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);</span><br><span class="line">    <span class="keyword">if</span> (!root.right) <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(minDepth(root.left), minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>输入一颗二叉树，判断该二叉树是否是平衡二叉树</p><p><strong>平衡二叉树的每个子树的深度之差不超过1</strong></p><p>思路：</p><p>后序遍历二叉树，在遍历二叉树每个节点前都会遍历其左右子树。比较左右子树的深度，若差值大于1则返回一个标记 -1，表示当前子树不平衡。</p><p>左右子树有一个不是平衡的，或左右子树差值大于1，则整棵树不平衡</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBalanced = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.abs(height(root.left) - height(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> height = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        reutrn <span class="built_in">Math</span>.max(height(root.left), height(root.right)) +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值得和为输入整数的所有路径。路径定义为从树的根节点开始往下一直到叶节点所经过的结点形成一条路径。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>套用回溯算法的思路</p><p>设定一个结果数组 result 来存储所有符合条件的路径</p><p>设定一个栈 stack 来存储当前路径中的结点</p><p>设定一个和 sum 来标识当前路径之和</p><ul><li>从根节点开始深度优先遍历，每经过一个节点，将节点入栈</li><li>到达叶子节点，且当前路径的和等于目标值，则找到一个可行的解决方案，将其加入到结果数组中</li><li>遍历到二叉树的某个节点时有 2 个可能的选项，选择前往左子树或右子树</li><li>若存在左子树，继续向左子树递归</li><li>若存在右子树，继续向右子树递归</li><li>若上述条件均不满足，或已经遍历过，将当前节点出栈，向上回溯</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindPath</span>(<span class="params">root, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        FindPathCore(root, data, [], <span class="number">0</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindPathCore</span>(<span class="params">node, data, stack, sum, result</span>) </span>&#123;</span><br><span class="line">    stack.push(node.val);</span><br><span class="line">    sum += node.val;</span><br><span class="line">    <span class="keyword">if</span>(!node.left &amp;&amp; !node.right &amp;&amp; sum === data) &#123;</span><br><span class="line">        result.push(stack.slice());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.left) &#123;</span><br><span class="line">        FindPathCore(node.left, data, stack, sum, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right) &#123;</span><br><span class="line">        FindPathCore(node.right, data, stack, sum, result);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>二叉搜索树的中序遍历即排序后的序列</p><ul><li>递归左子树，找到左子树的最后一个节点，根节点左侧连接到左子树的最后一个节点。</li><li>当前节点变为已经转换完成的链表的最后一个节点</li><li>递归右子树，找到当前树的最后一个节点</li><li>回溯到上一层，进行链接</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Convert</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ConvertCore(root);</span><br><span class="line">    <span class="keyword">while</span>(root.left) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConvertCore</span>(<span class="params">node, last</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">        last = ConvertCore(node.left, last);</span><br><span class="line">    &#125;</span><br><span class="line">    node.left = last;</span><br><span class="line">    <span class="keyword">if</span> (last) &#123;</span><br><span class="line">        last.right = node;</span><br><span class="line">    &#125;</span><br><span class="line">    last = node;</span><br><span class="line">    <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">        last = ConvertCore(node.right, last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node head, pre;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = root;</span><br><span class="line">            pre = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre.right = root;</span><br><span class="line">            root.left = pre;</span><br><span class="line">            pre = root;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><p>实现两个函数，分别实现序列化和反序列化二叉树</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li>若一棵二叉树是不完全的，至少需要两个遍历才能将其重建。但是这种方式有一定的局限性，比如二叉树中不能出现重复节点。</li><li>如果二叉树是一棵完全二叉树，只需要知道前序遍历即可将它重建</li><li>在序列化二叉树时，可以将空节点使用特殊符号存储起来，这样就可以模拟一棵完全二叉树的前序遍历</li><li>在重建二叉树时，当遇到特殊符号当空节点进行处理</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Serialize</span>(<span class="params">root, arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        arr.push(<span class="string">'#'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         arr.push(root.val);</span><br><span class="line">         Serialize(root.left);</span><br><span class="line">         Serialize(root.right);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">','</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deserialize</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deserialize(s.split(<span class="string">','</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deserialize</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> current = arr.shift();</span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="string">'#'</span>) &#123;</span><br><span class="line">        node = &#123; <span class="attr">val</span>: current &#125;;</span><br><span class="line">        node.left = deserialize(arr);</span><br><span class="line">        node.right = deserialize(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h3><p>给定一个二叉树和其中的一个结点，找出中序遍历的下一个结点并返回。注意，树中的结点不仅包含左右子节点，同时包含指向父节点的指针。</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>右节点不为空：去右节点的最左侧节点</li><li>右节点为空：如果节点是父节点的左节点，取父节点</li><li>右节点为空：如果节点是父节点的右节点，父节点已经被遍历过，再往上层寻找…</li><li>左节点一定在当前节点之前被遍历过</li></ul><p>如下图的二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   E</span><br><span class="line"> / \   \</span><br><span class="line">C   D   F</span><br></pre></td></tr></table></figure><p>中序遍历：<code>CBEDAEF</code></p><ul><li>B：右节点不为空，下一个节点为右节点 D</li><li>C：右节点为空，C 是父节点的左节点，取父节点 B</li><li>D：右节点为空，D 是父节点的右节点，再往上层分析，B 是其父节点的左节点，取 B 的父节点 A</li><li>F：右节点为空，F 是父节点的右节点，没有符合条件的节点，F 为遍历的最后一个节点，返回 null</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">root, node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    getNext(root.left);</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == node.val) &#123;</span><br><span class="line">        flag = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    getNext(root.right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">        root = root.right;</span><br><span class="line">        <span class="keyword">while</span>(root.left) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!root.next) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root == root.next.left) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.next;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><p>输入两棵二叉树 A、B，判断 B 是不是 A 的子结构（空树不是任意一个树的子结构）</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>首先找到 A 树中和 B 树根节点相同的节点。从此节点开始，从此节点开始递归 AB 树比较是否有不同节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HasSubtree</span>(<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 &amp;&amp; root2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1.val === root2.val) &#123;</span><br><span class="line">            result = compare(root1, root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            result = HasSubtree(root1.left, root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            result = HasSubtree(root1.right, root2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root2 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1.val !== root2.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compare(root1.left, root2.left) &amp;&amp; compare(root1.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树中寻找两个节点的最近公共祖先节点"><a href="#二叉树中寻找两个节点的最近公共祖先节点" class="headerlink" title="二叉树中寻找两个节点的最近公共祖先节点"></a>二叉树中寻找两个节点的最近公共祖先节点</h3><p>利用递归来做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lowestCommonAncestor = (root, v1, v2) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || root.val ==== v1 || root.val === v2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> left = lowestCommonAncestor(root.left, v1, v2);</span><br><span class="line">    <span class="keyword">const</span> right = lowestCommonAncestor(root.right, v1, v2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!left) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!right) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://uploadfiles.nowcoder.com/files/20201028/2659167_1603849216965_77299a6a0651c7942af18b564e9edc04.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树系列&quot;&gt;&lt;a href=&quot;#二叉树系列&quot; class=&quot;headerlink&quot; title=&quot;二叉树系列&quot;&gt;&lt;/a&gt;二叉树系列&lt;/h2&gt;&lt;p&gt;树是用来模拟具有树状结构性质的数据集合。根据性质可分为很多种类，只要了解二叉树这种结构就足够了，它是树中最简单、应用</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
  </entry>
  
</feed>
