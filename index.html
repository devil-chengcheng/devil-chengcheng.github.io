<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="小二、上酒" type="application/atom+xml">






<meta name="description" content="人生当苦无妨，良人当归即好">
<meta property="og:type" content="website">
<meta property="og:title" content="小二、上酒">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小二、上酒">
<meta property="og:description" content="人生当苦无妨，良人当归即好">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小二、上酒">
<meta name="twitter:description" content="人生当苦无妨，良人当归即好">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>小二、上酒</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小二、上酒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/BFS框架套路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/BFS框架套路/" itemprop="url">BFS框架套路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="BFS框架套路"><a href="#BFS框架套路" class="headerlink" title="BFS框架套路"></a>BFS框架套路</h2><ul>
<li>DFS：深度优先遍历</li>
<li>BFS：广度优先遍历</li>
</ul>
<p>DFS 深度优先遍历其实就是回溯算法。而 BFS 的核心思想就是将一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，BFS 算法一般都是使用队列这种数据结构，每次将一个节点周围的所有节点加入队列。</p>
<p>BFS 相对于 DFS 的最主要区别是：<strong>BFS 找到的路径一定是最短的，但是代价就是空间复杂度比DFS大很多</strong></p>
<h3 id="一、算法框架"><a href="#一、算法框架" class="headerlink" title="一、算法框架"></a>一、算法框架</h3><p>BFS 出现的常见场景。问题的<strong>本质就是在一幅图中找到起点 <code>start</code> 到终点 <code>target</code> 的最近距离</strong></p>
<p>这种广义描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？</p>
<p>再比如两个单词，要求通过某些替换，将其中一个变成另一个，每次只能替换一个字符，最少要替换几次。</p>
<p>这些问题的本质就是一幅图，从一个起点，走到终点，问最短路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点start到终点target的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">	Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">	Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">	</span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/*将当前队列中的所有节点向四周扩散*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/*重点：判断是否到达终点*/</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/*将cur的相邻节点加入队列*/</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*重点：更新步数在这里*/</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列是 BFS 的核心数据结构； <code>cur.adj()</code> 泛指 <code>cur</code> 相邻的节点，比如说二维数组中， <code>cur</code>上下左右四面位置就是相邻节点，<code>visited</code>的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要<code>visited</code></p>
<p>JS 框架：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bfs = (start, target) &#123;</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="keyword">const</span> visited = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    queue.push(start);</span><br><span class="line">    visited[start] = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> len = queue.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">            <span class="keyword">if</span> (node === target) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="keyword">for</span> (Node x : x.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not visited) &#123;</span><br><span class="line">                    queue.push(x);</span><br><span class="line">                	visited[x] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的最小高度"><a href="#二叉树的最小高度" class="headerlink" title="二叉树的最小高度"></a>二叉树的最小高度</h3><p>判断一棵二叉树的最小高度</p>
<p>怎么套到 BFS 框架中，首先明确一下起点 <code>start</code> 和 <code>target</code> 是什么，如何判断到达了终点。</p>
<p><strong>显然起点就是root根节点，终点就是靠近根节点的那个叶子节点</strong>，叶子节点就是两个子节点都是 null 的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 到达叶子节点</span></span><br></pre></td></tr></table></figure>

<p>按照上面的框架稍加改造写解法即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = q.size();</span><br><span class="line">        <span class="comment">/*当前队列中的节点向四周扩散*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            <span class="comment">// 判断是否到达终点</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> depth;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minDepth</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> len = queue.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> cur = queue.shift();</span><br><span class="line">            <span class="keyword">if</span> (!cur.left &amp;&amp; !cur.right) <span class="keyword">return</span> depth;</span><br><span class="line">            <span class="keyword">if</span> (cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right) queue.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    retrurn depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树是很简单的数据结构，其实其它复杂问题都是这个框架的变形。在讨论复杂问题之前，解答两个问题:</p>
<p><strong>1. 为什么BFS可以找到最短路径，而DFS不行</strong></p>
<p>首先，BFS 的逻辑，<code>depth</code>每增加一次，队列中的所有结点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。</p>
<p>DFS 其实也可以找最短路径，但是时间复杂度相对高很多。DFS 实际上靠递归的堆栈记录走过的路径，要找到最短路径，得将二叉树中所有树枝都探索完才能对比出最短的路径。而 DFS可以在不遍历完整棵树的条件下找到最短距离的。</p>
<p><strong>2. 既然BFS这么好，为什么还要DFS存在</strong></p>
<p>BFS可以找到最短距离，但是空间复杂度高，而DFS的空间复杂度较低。</p>
<p>假设二叉树是满二叉树，节点数为<code>N</code>，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏的情况下顶多就是树的高度，也就是<code>O(logN)</code></p>
<p>但是如果是 BFS 算法，队列中每次都会存储着二叉树一层的结点，这种情况下最坏的空间复杂度是树的最底层节点的数量，也就是 <code>N/2</code>.</p>
<p>所以，BFS还是有代价的。一般来说在找最短路径的时候使用 BFS，其它时候还是 DFS 使用的多一些（主要递归代码好写）</p>
<h3 id="解开密码锁的最少次数"><a href="#解开密码锁的最少次数" class="headerlink" title="解开密码锁的最少次数"></a>解开密码锁的最少次数</h3><p>有一个有四个拨轮的转盘锁，每个拨轮有10个数字：0-9。每个拨轮可自由旋转。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>锁的初始数字为 <code>0000</code>，一个代表四个拨轮的数字的字符串。</p>
<p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁就会被永久锁定，无法再被旋转。</p>
<p>字符串 <code>target</code> 代表可以解锁的数字，需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1</p>
<p>题目描述的就是生活中常见的密码锁，若没有任何约束，最少的拨动次数很好算，就像平时开密码锁那样直奔密码拨就行。</p>
<p>但现在的难点在于，不能出现 <code>deadends</code> ，应该如何计算出最少的转动次数呢</p>
<p><strong>首先，不管所有的限制条件，不管 <code>deadends</code> 和 <code>target</code>的限制，就思考一个问题：如果设计一个算法，穷举所有的密码组合，如何做</strong></p>
<p>就穷举，再简单一点，如果只转一下锁，有几种可能。总共有四个位置，每个位置可以向上、下两个方向转，也就是 8 种可能。</p>
<p><strong>这可以抽象成一幅图，每个节点有 8 个相邻的节点</strong>，又是求最短距离，典型的 BFS。</p>
<p>可以先写一个简陋的 BFS 框架代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 s[j] 向上拨动一次</span></span><br><span class="line"><span class="function">String <span class="title">plusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(ch[j] == <span class="string">'9'</span>)</span><br><span class="line">        ch[j] = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ch[j] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 s[i] 向下拨动一次</span></span><br><span class="line"><span class="function">String <span class="title">minusOne</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(ch[i] == <span class="string">'0'</span>)</span><br><span class="line">        ch[i] = <span class="string">'9'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ch[i] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 框架，打印出所有可能的密码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(<span class="string">"0000"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line">            <span class="comment">/*判断是否到达终点*/</span></span><br><span class="line">            <span class="keyword">if</span> (cur.equals(target))</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*将一个节点的相邻节点加入队列*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                q.offer(up);</span><br><span class="line">                q.offer(down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*这里增加步数*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这段代码已经能够穷举所有可能的密码组合了，但是显然不能完成题目，有如下问题需要解决：</strong></p>
<ol>
<li>会走回头路。比如从 <code>0000</code>拨到 <code>1000</code> ，但是等从队列拿出 <code>1000</code> 时，还会拨出一个 <code>0000</code>，这样的话会产生死循环。</li>
<li>没有终止条件，按照题目要求，找到 <code>target</code> 就结束并返回拨动的次数。</li>
<li>没有对 <code>deadends</code> 的处理，按道理这些死亡密码是不能出现的，即遇到这些密码的时候需要跳过。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录需要跳过的死亡密码</span></span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : deadends) deads.add(s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录已经穷举过的密码，防止走回头路</span></span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 从起点开始启动广度优先搜索</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q.offer(<span class="string">"0000"</span>);</span><br><span class="line">    visited.add(<span class="string">"0000"</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = q.size();</span><br><span class="line">        <span class="comment">/*将当前队列的所有节点向周围扩散*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*判断是否到达终点*/</span></span><br><span class="line">            <span class="keyword">if</span> (deads.contains(cur))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.equals(target))</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*将一个节点的未遍历相邻节点加入队列*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(up)) &#123;</span><br><span class="line">                    q.offer(up);</span><br><span class="line">                    visited.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(down)) &#123;</span><br><span class="line">                    q.offer(down);</span><br><span class="line">                    visited.add(down);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果穷举完都没找到目标密码，那就是找不到了。</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这道题目就解决了。有一个比较小的优化：可以不需要 <code>dead</code> 这个哈希集合，可以直接将这些元素初始化到 <code>visited</code>集合中，效果是一样的。</p>
<h3 id="双向-BFS-优化"><a href="#双向-BFS-优化" class="headerlink" title="双向 BFS 优化"></a>双向 BFS 优化</h3><p>BFS 算法还有一种稍微高级一点的优化思路：<strong>双向BFS</strong>，可以进一步提高算法效率。</p>
<p>区别：<strong>传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止</strong>。</p>
<p>如果终点在最底部，按照传统 BFS 算法的策略，会把整棵树的节点都搜索一遍，最后找到 <code>target</code>;而双向 BFS 其实只遍历了半棵树就出现了交集，也就是找到了最短距离。</p>
<p><strong>不过，双向 BFS 也有局限，因为必须知道终点在哪里</strong>。比如二叉树最小高度的问题，一开始根本就不知道终点在哪里，也就无法使用双向 BFS ，但是第二个密码锁问题是可以使用双向 BFS 算法来提高效率的。代码稍加修改即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : deadends) deads.add(s);</span><br><span class="line">    <span class="comment">// 用集合不用队列可快速判断元素是否存在</span></span><br><span class="line">    Set&lt;String&gt; q1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; q2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q1.add(<span class="string">"0000"</span>);</span><br><span class="line">    q2.add(target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q1.isEmpty() &amp;&amp; !q2.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果</span></span><br><span class="line">        Set&lt;String&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将q1中的所有结点向周围扩散</span></span><br><span class="line">        <span class="keyword">for</span> (String cur:q1) &#123;</span><br><span class="line">            <span class="comment">// 判断是否到达终点</span></span><br><span class="line">            <span class="keyword">if</span> (deads.contains(cur))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (q2.contains(cur))</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            visited.add(cur);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将一个结点的未遍历相邻结点加入集合</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(up))</span><br><span class="line">                    temp.add(up);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(down))</span><br><span class="line">                    temp.add(down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">        <span class="comment">// temp相当于 q1</span></span><br><span class="line">        <span class="comment">// 这里交换 q1,q2, 下一轮 while 就是扩散 q2</span></span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双向 BFS 还是遵循 BFS 算法框架的，只是<strong>不再使用队列，而是使用 <code>HashSet</code> 方便快速判断两个集合是否有交集</strong>。</p>
<p>另外一个技巧就是 <strong>while 循环的最后交换 <code>q1</code> 和 <code>q2</code> 的内容</strong>，所以只要默认扩散 <code>q1</code> 就相当于轮流扩散 <code>q1</code> 和 <code>q2</code>.</p>
<p><strong>不过，无论传统 BFS 还是双向 BFS，无论做不做优化，时间复杂度都是一样的，</strong>只能说双向 BFS 是一种 trick ，算法运行的速度会相对快一点。双向 BFS 掌握不掌握都无所谓。</p>
<h3 id="BFS-题目"><a href="#BFS-题目" class="headerlink" title="BFS 题目"></a>BFS 题目</h3><h4 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h4><p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<ul>
<li><p>值 0 代表空单元格；</p>
</li>
<li><p>值 1 代表新鲜橘子；</p>
</li>
<li><p>值 2 代表腐烂的橘子。</p>
<p>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>
</li>
</ul>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> orangesRotting = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 新鲜橘子数量</span></span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] === <span class="number">2</span>) &#123;</span><br><span class="line">                queue.push([i, j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> round = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count&gt;<span class="number">0</span> &amp;&amp; queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        round++;</span><br><span class="line">        <span class="keyword">const</span> len = queue.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> temp = queue.shift();</span><br><span class="line">            <span class="keyword">let</span> row = temp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">let</span> col = temp[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (row<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row<span class="number">-1</span>][col] === <span class="number">1</span>) &#123;</span><br><span class="line">                grid[row<span class="number">-1</span>][col] = <span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.push([row<span class="number">-1</span>, col]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (row+<span class="number">1</span> &lt; grid.length &amp;&amp; grid[row+<span class="number">1</span>][col] === <span class="number">1</span>) &#123;</span><br><span class="line">                grid[row+<span class="number">1</span>][col] = <span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.push([row+<span class="number">1</span>, col]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (col<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col<span class="number">-1</span>] === <span class="number">1</span>) &#123;</span><br><span class="line">                grid[row][col<span class="number">-1</span>] = <span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.push([row, col<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (col+<span class="number">1</span> &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[row][col+<span class="number">1</span>] === <span class="number">1</span>) &#123;</span><br><span class="line">                grid[row][col+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.push([row, col+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> round;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h4><p>广度优先遍历BFS， 因为需要输出路径；所以使用一个数组 prev 来记录坐标 (x, y) 的上一个坐标</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (line = readline()) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = <span class="built_in">parseInt</span>(line.split(<span class="string">' '</span>)[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> n = <span class="built_in">parseInt</span>(line.split(<span class="string">' '</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> arr = [];</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> prev = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        arr.push(readline().split(<span class="string">' '</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="keyword">const</span> visited = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        visited.push(<span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="literal">false</span>));</span><br><span class="line">        prev.push(<span class="keyword">new</span> <span class="built_in">Array</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue.push([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> len = queue.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = queue.shift();</span><br><span class="line">        <span class="keyword">let</span> row = tmp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> col = tmp[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (row === m - <span class="number">1</span> &amp;&amp; col === n - <span class="number">1</span>) &#123;</span><br><span class="line">          res.unshift([row, col])</span><br><span class="line">          <span class="keyword">while</span> (row !== <span class="number">0</span> || col !== <span class="number">0</span>) &#123;</span><br><span class="line">            res.unshift(prev[row][col])</span><br><span class="line">            <span class="keyword">const</span> tp = prev[row][col];</span><br><span class="line">            [row, col] = tp;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'('</span> + res[i][<span class="number">0</span>] + <span class="string">','</span> + res[i][<span class="number">1</span>] + <span class="string">')'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上</span></span><br><span class="line">        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[row - <span class="number">1</span>][col] &amp;&amp; arr[row - <span class="number">1</span>][col] !== <span class="string">'1'</span>) &#123;</span><br><span class="line">          queue.push([row - <span class="number">1</span>, col]);</span><br><span class="line">          visited[row - <span class="number">1</span>][col] = <span class="literal">true</span>;</span><br><span class="line">          prev[row - <span class="number">1</span>][col] = [row, col];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下</span></span><br><span class="line">        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; m &amp;&amp; !visited[row + <span class="number">1</span>][col] &amp;&amp; arr[row + <span class="number">1</span>][col] !== <span class="string">'1'</span>) &#123;</span><br><span class="line">          queue.push([row + <span class="number">1</span>, col]);</span><br><span class="line">          visited[row + <span class="number">1</span>][col] = <span class="literal">true</span>;</span><br><span class="line">          prev[row + <span class="number">1</span>][col] = [row, col];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向左</span></span><br><span class="line">        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[row][col - <span class="number">1</span>] &amp;&amp; arr[row][col - <span class="number">1</span>] !== <span class="string">'1'</span>) &#123;</span><br><span class="line">          queue.push([row, col - <span class="number">1</span>]);</span><br><span class="line">          visited[row][col - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">          prev[row][col - <span class="number">1</span>] = [row, col];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向右</span></span><br><span class="line">        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; n &amp;&amp; !visited[row][col + <span class="number">1</span>] &amp;&amp; arr[row][col + <span class="number">1</span>] !== <span class="string">'1'</span>) &#123;</span><br><span class="line">          queue.push([row, col + <span class="number">1</span>]);</span><br><span class="line">          visited[row][col + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">          prev[row][col + <span class="number">1</span>] = [row, col];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/字符串/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/字符串/" itemprop="url">字符串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="字符串专题"><a href="#字符串专题" class="headerlink" title="字符串专题"></a>字符串专题</h2><ul>
<li>替换空格</li>
<li>表示数值的字符串</li>
<li>字符流中能第一个不重复的字符</li>
<li>字符串的排列</li>
<li>字符串翻转</li>
<li>正则表达式匹配</li>
</ul>
<h4 id="1-替换空格"><a href="#1-替换空格" class="headerlink" title="1. 替换空格"></a>1. 替换空格</h4><p>实现一个函数，将字符串中的每个空格替换成 <code>&quot;%20&quot;</code>。例如，当字符串为 <code>We Are Happy</code> ，则经过替换之后的字符串为 <code>We20%Are20%Happy</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/\s/g</span>, <span class="string">'%20'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">Str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">' '</span>).join(<span class="string">'%20'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>拓展</strong></p>
<p>允许出现多个空格，多个空格用一个 <code>%20</code> 替换。（用正则表达式找到连续空格进行替换）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/\s+/g</span>, <span class="string">'%20'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-表示数值的字符串"><a href="#2-表示数值的字符串" class="headerlink" title="2. 表示数值的字符串"></a>2. 表示数值的字符串</h4><p>(leetcode上的编译简直流氓)</p>
<p>实现一个函数来判断字符串是否表示数值（包括整数和小数）。例如，字符串<code>”+100“，”5e2“, &quot;-123&quot;, &quot;3.1416&quot;</code> 和 <code>”-1E-16“</code> 都表示数值。 但是<code>&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;</code>和<code>&quot;12e+4.3&quot;</code>都不是。</p>
<p>考虑完全所有情况：</p>
<ul>
<li>只能出现数字、符号位、小数点、指数位</li>
<li>小数点，指数符号只能出现一次，且不能出现在开头结尾</li>
<li>指数位出现后，小数点不允许再出现</li>
<li>符号位只能出现在开头和指数位后面</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hasPoint = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> hasExp = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.replace(<span class="regexp">/\s*/</span>, <span class="string">''</span>).length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] &gt;= <span class="number">0</span> &amp;&amp; s[i] &lt;= <span class="number">9</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">'.'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasPoint || hasExp || i === <span class="number">0</span> || i === s.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      hasPoint = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">'e'</span> || s[i] === <span class="string">'E'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasExp || i === <span class="number">0</span> || i === s.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      hasExp = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">'+'</span> || s[i] === <span class="string">'-'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">0</span> || s[i - <span class="number">1</span>] === <span class="string">'e'</span> || s[i - <span class="number">1</span>] === <span class="string">'E'</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>极致的简单解法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="keyword">if</span> (!s.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isNaN</span>(<span class="built_in">Number</span>(s.trim()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-字符流中第一个不重复的字符"><a href="#3-字符流中第一个不重复的字符" class="headerlink" title="3. 字符流中第一个不重复的字符"></a>3. 字符流中第一个不重复的字符</h4><p>实现一个函数用来找字符流中第一个只出现一次的字符。如果当前字符流没有存在出现一次的字符，返回 # 字符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> a = s[i];</span><br><span class="line">        map.has(a) ? map.set(a, map.get(a)+<span class="number">1</span>) : map.set(a, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> a = s[i];</span><br><span class="line">        <span class="keyword">if</span> (map.get(a) === <span class="number">1</span>) <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-字符串的排列"><a href="#4-字符串的排列" class="headerlink" title="4. 字符串的排列"></a>4. 字符串的排列</h4><p>输入一个字符串，按字典打印该字符串中字符的所有排列。</p>
<p>这是回溯问题 + 剪枝。类似之前的全排列问题，只不过这里要更复杂些，这是存在重复字符的可能。</p>
<p>先假设没有重复字符出现，此时的代码就相当于使用回溯框架：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permutation = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> track = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> backtrack = <span class="function"><span class="keyword">function</span>(<span class="params">s, track</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (track.length === s.length) &#123;</span><br><span class="line">            res.push(track.join(<span class="string">''</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;s.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (track.includes(s[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.push(s[i]);</span><br><span class="line">            backtrack(s, track);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    backtrack(s, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有重复字符的存在，题目还是很简单的，但是如果条件改变，存在重复的字符，那么上面的代码就不适用，而且需要考虑的就多了。</p>
<ul>
<li>首先还是可以利用回溯算法的框架，但是不能靠 判断 <code>track</code> 数组来判断剪枝了</li>
<li>需要两个数组，一个数组对选择进行存储，去除重复的可能；另一个数组用于将之前选过的排除</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permutation = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> track = [];</span><br><span class="line">    <span class="keyword">const</span> visited = &#123;&#125;; <span class="comment">// 相当于之前的的 track 判断是否遍历过的功能</span></span><br><span class="line">    <span class="keyword">const</span> backtrack = <span class="function"><span class="keyword">function</span>(<span class="params">s, track</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (track.length === s.length) &#123;</span><br><span class="line">            res.push(track.join(<span class="string">''</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> inclu = []; <span class="comment">// 保存当前位置确定的元素，放置不重复的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;s.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (inclu.includes(s[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            inclu.push(s[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            track.push(s[i]);</span><br><span class="line">            backtrack(s, track);</span><br><span class="line">            track.pop();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(s, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-字符串翻转"><a href="#5-字符串翻转" class="headerlink" title="5. 字符串翻转"></a>5. 字符串翻转</h4><h5 id="（1）翻转单词顺序"><a href="#（1）翻转单词顺序" class="headerlink" title="（1）翻转单词顺序"></a>（1）翻转单词顺序</h5><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。</p>
<ul>
<li>利用 JS 内置函数进行解决</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.trim().split(<span class="regexp">/\s+/g</span>).reverse().join(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-左旋转字符串"><a href="#2-左旋转字符串" class="headerlink" title="(2) 左旋转字符串"></a>(2) 左旋转字符串</h5><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。例如输入字符串 <code>&quot;abcdefg&quot;</code> 和数字 2 ，该函数将返回左旋转 2 位得到的结果 <code>&quot;cdefgab&quot;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="function"><span class="keyword">function</span>(<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=n; i&lt;s.length; i++) &#123;</span><br><span class="line">        res.push(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        res.push(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">''</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以先拼接两个字符串，再截取</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="function"><span class="keyword">function</span>(<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &amp;&amp; n!= <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (s + s).substr(n, s.length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-正则表达式匹配"><a href="#6-正则表达式匹配" class="headerlink" title="6. 正则表达式匹配"></a>6. 正则表达式匹配</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/栈和队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/栈和队列/" itemprop="url">栈和队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>数组中，我们可以通过索引随机访问元素，但是再某些情况下，我们需要限制数据的访问顺序，于是就有两种限制访问顺序的数据结构：栈（先进后出）、队列（先进先出）</p>
<h4 id="队列和栈的互相实现"><a href="#队列和栈的互相实现" class="headerlink" title="队列和栈的互相实现"></a>队列和栈的互相实现</h4><h5 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h5><p>用两个栈来实现一个队列，完成队列的 push 和 pop 操作。队列中的元素为 int 类型</p>
<p><strong>思路：</strong>两个栈，栈 1 用于入队列存储；栈 2 用于出队列时将栈 1 的数据依次出栈，并入栈到栈 2 中。栈 2 出栈即栈 1 底部数据即队列要出的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack1 = [];</span><br><span class="line"><span class="keyword">const</span> stack2 = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stack2.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack2.pop() || <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="两个队列实现一个栈"><a href="#两个队列实现一个栈" class="headerlink" title="两个队列实现一个栈"></a>两个队列实现一个栈</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue1 = [];</span><br><span class="line"><span class="keyword">const</span> queue2 = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue1.length === <span class="number">0</span>) &#123;</span><br><span class="line">        queue1.push(x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(queue2.length) &#123;</span><br><span class="line">            queue1.push(queue2.shift())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue2.length === <span class="number">0</span>) &#123;</span><br><span class="line">        queue2.push(X);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(queue1.length) &#123;</span><br><span class="line">            queue2.push(queue1.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue1.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.shift();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue2.shift();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-包含-min-函数的栈"><a href="#2-包含-min-函数的栈" class="headerlink" title="2. 包含 min 函数的栈"></a>2. 包含 min 函数的栈</h4><p>定义栈的数据结构，在该类型中实现以恶搞能够得到栈中所含最小元素的 min 函数</p>
<p><strong>思路：</strong></p>
<ul>
<li>定义两个栈，一个栈用于存储数据，另一个栈用于存储每次数据进栈时栈的最小值。</li>
<li>每次数据进栈时，将数据和最小值栈的栈顶元素进行比较，将较小的值存入最小值栈中</li>
<li>数据栈出栈，最小值栈也出栈。这样最小值栈的栈顶永远是当前栈的最小值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataStack = [];</span><br><span class="line"><span class="keyword">const</span> minStack = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    dataStack.push(node);</span><br><span class="line">    <span class="keyword">if</span> (minStack.length === <span class="number">0</span> || node&lt;min()) &#123;</span><br><span class="line">        minStack.push(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        minStack.push(min());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    minStack.pop();</span><br><span class="line">    dataStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">top</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = dataStack.length;</span><br><span class="line">    <span class="keyword">return</span> length&gt;<span class="number">0</span> &amp;&amp; dataStack[length<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = minStack.length;</span><br><span class="line">    <span class="keyword">return</span> length&gt;<span class="number">0</span> &amp;&amp; minStack[length<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-栈的压入、弹出序列"><a href="#3-栈的压入、弹出序列" class="headerlink" title="3. 栈的压入、弹出序列"></a>3. 栈的压入、弹出序列</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 <code>1,2,3,4,5</code> 是某栈的压入顺序，序列 <code>4,5,3,2,1</code>是该压栈序列对应的一个弹出序列，但 <code>4,3,5,1,2</code> 就不可能是该压栈序列的弹出序列。</p>
<p><strong>思路：</strong></p>
<ul>
<li>借助一个辅助栈来模拟压入、弹出的过程</li>
<li>设置一个索引 <code>idx</code>，记录出栈序列栈顶的位置</li>
<li>将压入顺序中的数据依次入栈</li>
<li>当辅助栈栈顶氧元素和压栈顶元素相同时，辅助栈出栈，每次出栈索引 <code>idx + 1</code></li>
<li>出栈有可能在任意一次入栈后进行，当辅助栈栈顶元素和压栈栈顶元素相同时，继续让 压入序列入</li>
<li>当所有数据入栈完成，如果出栈顺序正确，那么辅助栈为空</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPopOrder</span>(<span class="params">pushV, popV</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = []; <span class="comment">// 辅助栈</span></span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;pushV.length; i++) &#123;</span><br><span class="line">        stack.push(pushV[i]);</span><br><span class="line">        <span class="keyword">while</span>(stack.length &amp;&amp; stack[stack.length<span class="number">-1</span>] === popV[idx]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-滑动窗口的最大值"><a href="#4-滑动窗口的最大值" class="headerlink" title="4. 滑动窗口的最大值"></a>4. 滑动窗口的最大值</h4><p>给定一个数组 <code>nums</code> ，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。滑动窗口每次只向右移动一位。返回滑动窗口最大值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">window</span> = [];</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">window</span>.length &amp;&amp; nums[i] &gt;= nums[<span class="built_in">window</span>[<span class="built_in">window</span>.length - <span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="built_in">window</span>.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">window</span>.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(nums[<span class="built_in">window</span>[<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=k; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">window</span>.length &amp;&amp; nums[i] &gt;= nums[<span class="built_in">window</span>[<span class="built_in">window</span>.length- <span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="built_in">window</span>.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">window</span>.push(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">window</span>[<span class="number">0</span>] &lt;= i-k) &#123;</span><br><span class="line">            <span class="built_in">window</span>.shift()</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(nums[<span class="built_in">window</span>[<span class="number">0</span>]])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/图的逻辑和实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/图的逻辑和实现/" itemprop="url">图的逻辑和实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="图的逻辑和实现"><a href="#图的逻辑和实现" class="headerlink" title="图的逻辑和实现"></a>图的逻辑和实现</h2><p>图可以玩出更多的算法，解决更复杂的问题，但本质上图可以认为是多叉树的延申。</p>
<p>面试笔试很少出现图相关的问题，就算有，大多也是简单的遍历问题，基本可以完全照搬多叉树的遍历。</p>
<p>至于最小生成树，Dijkstra，网络流这些算法，学习的成本高，但收益低，没有性价比，不如多刷几道动态规划。</p>
<p>图是由<strong>节点</strong>和<strong>边</strong>构成的。根据逻辑结构，我们可以认为每个节点的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图节点的逻辑结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	Vertex[] neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现几乎和多叉树节点一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基本的 N 叉树节点*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	TreeNode[] children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这种实现是逻辑上的，实际上很少用这个 Vertex 类实现图，而是用常说的<strong>邻接表和邻接矩阵</strong>来实现。</p>
<p><strong>邻接表</strong>很直观，将每个节点 x 的邻居都存到一个列表里，然后将 x 和这个列表关联起来，这样就可以通过一个节点 x 找到它的所有相邻节点。</p>
<p><strong>邻接矩阵</strong>是一个二维布尔数组 matrix，如果节点 x 和 y 是相连的，就将<code>matrix[x][y]</code>设为 true。</p>
<p>两种存储图的方式，各有优劣。</p>
<ul>
<li>对于邻接表，好处是占用空间少；邻接矩阵需要更多的存储空间，也易造成浪费。</li>
<li>邻接表是无法快速判断两个节点是否相邻，邻接矩阵可以快速判断，效率高。</li>
</ul>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历可以参考多叉树，多叉树的遍历框架如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">		traverse(child);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图和多叉树最大的区别是，图是可能包含环的，你从图的某一个节点开始遍历，可能走一圈又回到这个节点。</p>
<p>所以，如果图包含闭环，遍历框架就需要一个 visited 数组进行辅助：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 经过节点 s</span></span><br><span class="line">	visited[s] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (TreeNode neighbor : graph.neighbors(s))</span><br><span class="line">		traverse(neighbor);</span><br><span class="line">	<span class="comment">// 离开节点 s</span></span><br><span class="line">	visited[s] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 visited 数组的操作很像回溯算法中的“做选择”和”撤销选择“，区别在于位置，回溯算法中的操作是在 for 循环里面，而对 visited 数组的操作在 for 循环外面。唯一的区别就是对根节点的处理。</p>
<p>比如下面两种多叉树的遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.println(<span class="string">"enter:"</span> + root.val);</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"leave:"</span> + root.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        System.out.println(<span class="string">"enter:"</span> + child.val);</span><br><span class="line">        traverse(child);</span><br><span class="line">        System.out.println(<span class="string">"leave:"</span> + child.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前者会正确打印所有节点的进入和离开信息，后者唯独会少打印整棵树根节点的进入和离开信息。</p>
<p>回溯算法关注的不是节点，而是树枝，所以回溯算法框架会使用后者。</p>
<p>对于图的遍历，应该把 visited 的操作放到 for 循环外面，否则会漏掉起始点的遍历。</p>
<p>当然，<strong>当有向图含有环的时候才需要 visited 数组辅助</strong>，如果不含环，连 visited 数组都省了，基本就是多叉树的遍历。</p>
<h3 id="题目实践"><a href="#题目实践" class="headerlink" title="题目实践"></a>题目实践</h3><h4 id="所有可能路径"><a href="#所有可能路径" class="headerlink" title="所有可能路径"></a>所有可能路径</h4><p>leetcode 797题</p>
<p>题目输入一幅有向无环图，这个图包含 n 个节点，标号为 0, 1, 2,…, n-1，计算所有从节点 0 到节点 n-1 的路径。</p>
<p>输入这个 graph 其实就是 邻接表 表示的一幅图，<code>graph[i]</code>存储这个节点 i 的所有邻居节点。</p>
<p>比如输入 <code>graph = [[1, 2], [3], [3], []]</code></p>
<p>算法应该返回 <code>[[0, 1, 3], [0, 2, 3]]</code>，即 0 到 3 的所有路径。</p>
<p><strong>算法很简单，以 0 为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可</strong></p>
<p>输入的是有向无环，就不需要 visited 数组辅助</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录所有路径</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    traverse(graph, <span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*图的遍历框架*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> s, LinkedList&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加节点 s 到路径</span></span><br><span class="line">    path.addLast(s);</span><br><span class="line">    <span class="keyword">int</span> n = graph.length;</span><br><span class="line">    <span class="keyword">if</span> (s == n-<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 到达终点</span></span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">        path.removeLast();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归每个相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : graph[s]) &#123;</span><br><span class="line">        traverse(graph, v, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从路径中移除节点s</span></span><br><span class="line">    path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    traverse(graph, <span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> s, List&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">    path.add(s);</span><br><span class="line">    <span class="keyword">if</span> (s == graph.length-<span class="number">1</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归每个相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : graph[s]) &#123;</span><br><span class="line">        traverse(graph, v, path);</span><br><span class="line">    &#125;</span><br><span class="line">    path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/双指针技巧总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/双指针技巧总结/" itemprop="url">双指针技巧总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="双指针技巧总结"><a href="#双指针技巧总结" class="headerlink" title="双指针技巧总结"></a>双指针技巧总结</h2><p>双指针分为两类，一类是快慢指针，一类是左右指针。前者主要解决链表中的问题，比如典型的判断链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。</p>
<h3 id="一、快慢指针"><a href="#一、快慢指针" class="headerlink" title="一、快慢指针"></a>一、快慢指针</h3><p>快慢指针一般都初始化指向链表的头结点 <code>head</code>，前进时快指针 <code>fast</code> 在前，慢指针 <code>slow</code> 在后，巧妙解决一些链表中的问题。</p>
<ul>
<li>判断链表中是否有环</li>
<li>假设链表中有环，求环的初始点</li>
<li>寻找链表的中点</li>
<li>寻找链表的倒数第 n 个节点</li>
</ul>
<h5 id="1-判断链表中是否有环"><a href="#1-判断链表中是否有环" class="headerlink" title="1. 判断链表中是否有环"></a>1. 判断链表中是否有环</h5><p>这属于链表的最基本操作。</p>
<p>单链表的特点时每个节点只知道下一个节点，所以一个指针无法判断链表中是否有环的。</p>
<p>如果链表中不含环，那么指针最终会遇到空指针 <code>null</code> 表示链表到头了，这样可以判断该链表不含环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形链表中没有 <code>null</code> 指针作为尾部节点。</p>
<p>经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含环，跑的快的那个指针最终会遇到 <code>null</code>，说明链表不含环；如果含有环，快指针最终会超满指针一圈，和慢指针相遇，说明链表含有环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-已知链表中含有环，返回这个环的起始位置"><a href="#2-已知链表中含有环，返回这个环的起始位置" class="headerlink" title="2. 已知链表中含有环，返回这个环的起始位置"></a>2. 已知链表中含有环，返回这个环的起始位置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当快慢指针相遇时，让其中任一个指针指向头结点，然后让他俩以相同的速度前进，再次相遇时所在的节点就是环开始的位置。</p>
<p>第一次相遇时，假设慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步；</p>
<p><code>fast</code> 一定比 <code>slow</code> 多走了 <code>k</code> 步，这多走的 <code>k</code> 步就是 <code>fast</code> 指针在环中转圈圈，所以 <code>k</code> 值就是环长度的整数倍。</p>
<p>设相遇点距环的起点的距离为 <code>m</code> ，那么环的起点距头结点 <code>head</code> 的距离为 <code>k-m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。而巧的是，如果从相遇点继续前进 <code>k-m</code> 步，也恰好到达环起点。</p>
<p>所以只要将快慢指针中的任一个重新指向 <code>head</code> ，然后两个指针同速前进，<code>k-m</code> 步后就会相遇，相遇之处就是环的起点了。</p>
<h5 id="3-寻找链表的中点"><a href="#3-寻找链表的中点" class="headerlink" title="3. 寻找链表的中点"></a>3. 寻找链表的中点</h5><p>类似上面的思路，可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slow 就在中间位置</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当链表的长度是奇数时，<code>slow</code> 恰巧停在中点位置；如果长度是偶数， <code>slow</code> 的位置是中间偏右。</p>
<p>寻找链表中点的一个重要作用是对链表进行归并排序。</p>
<p>回想数组的归并排序：求中点索引递归的将数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。</p>
<p>但是现在能够寻找链表的中点，就能实现链表的二分了。</p>
<h5 id="4-寻找链表的倒数第-n-个元素"><a href="#4-寻找链表的倒数第-n-个元素" class="headerlink" title="4. 寻找链表的倒数第 n 个元素"></a>4. 寻找链表的倒数第 n 个元素</h5><p>删除链表中倒数第 n 个节点。</p>
<p>思路还是使用快慢指针，让快指针先走 n 步，然后快慢指针同速前进。这样当快指针走到链表末尾 <code>null</code> 时，慢指针所在的位置就是倒数第 n 个链表节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果此时快指针走到头了，说明倒数第 n 个节点就是第一个节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让慢指针和快指针同步向前</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slow.next 就是倒数第 n 个节点</span></span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、左右指针"><a href="#二、左右指针" class="headerlink" title="二、左右指针"></a>二、左右指针</h3><p>左右指针在数组中实际是指两个索引值，一般初始化为 <code>left=0, right=nums.length-1</code></p>
<h5 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-两数之和"><a href="#2-两数之和" class="headerlink" title="2. 两数之和"></a>2. 两数之和</h5><p>给定一个按升序排列的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>只要数组有序，就应该想到双指针技巧。这题解法类似二分查找，通过调节 <code>left</code> 和 <code>right</code> 可以调整 <code>sum</code> 的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left+<span class="number">1</span>, right+<span class="number">1</span>&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            left++; <span class="comment">// 让 sum 大一点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            right--; <span class="comment">// 让 sum 小一点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-反转数组"><a href="#3-反转数组" class="headerlink" title="3. 反转数组"></a>3. 反转数组</h5><p>一般编程语言都会提供 reverse 函数，其实非常简单，leetcode 344 题是类似需求，反转一个 <code>char[]</code> 类型的字符数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 交换 arr[left] 和 arr[right]</span></span><br><span class="line">        <span class="keyword">char</span> temp = arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-滑动窗口算法"><a href="#4-滑动窗口算法" class="headerlink" title="4. 滑动窗口算法"></a>4. 滑动窗口算法</h5><p>这是双指针技巧的最高境界，掌握该算法，可以解决一大类子字符串匹配的问题，不过滑动窗口算法稍微复杂，详情见滑动窗口的模板框架</p>
<h5 id="5-接雨水问题"><a href="#5-接雨水问题" class="headerlink" title="5. 接雨水问题"></a>5. 接雨水问题</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxWater</span>(<span class="params"> arr </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[left] &lt; arr[right]) &#123;</span><br><span class="line">            left_max = <span class="built_in">Math</span>.max(left_max, arr[left]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (arr[left] &lt; left_max) &#123;</span><br><span class="line">                res += left_max - arr[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right_max = <span class="built_in">Math</span>.max(right_max, arr[right]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (arr[right] &lt; right_max) &#123;</span><br><span class="line">                res += right_max - arr[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/数组概览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/数组概览/" itemprop="url">数组概览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数组概览"><a href="#数组概览" class="headerlink" title="数组概览"></a>数组概览</h2><p>数组是开发中最常见的数据结构了，用于按顺序存储元素的集合。但是元素可以随机存取，因为数组中的每个元素都可以通过索引来识别。插入和删除时要移动后续元素，还要考虑扩容问题，插入速度慢。</p>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>用于数组的双指针一般是左右指针，但是快慢指针也是适用的。主要<strong>利用两个或多个不同位置的指针，通过速度和方向的变换解决问题</strong>。这种技巧经常在排序数组中使用。</p>
<ul>
<li>调整数组顺序使奇数位于偶数前面</li>
<li>和为 S 的两个数字</li>
<li>和为 S 的连续正整数序列</li>
</ul>
<h3 id="N-数之和问题"><a href="#N-数之和问题" class="headerlink" title="N 数之和问题"></a>N 数之和问题</h3><p>非常常见的问题，基本上另一个套路，主要考虑如何比暴力法降低时间复杂度，而且也会用到双指针技巧</p>
<ul>
<li>两数之和</li>
<li>三数之和</li>
<li>四数之和</li>
</ul>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>建立一定的抽象建模能力，将实际中的很多问题进行抽象</p>
<ul>
<li>构建乘积数组</li>
<li>顺时针打印矩阵</li>
</ul>
<h3 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h3><p>数组少不了的就是统计和计算，此类问题考察如何利用更高效的方法对数组进行统计计算</p>
<ul>
<li>数组中出现次数超过数组长度一半的数字</li>
<li>连续子数组的最大和</li>
<li>扑克牌顺子</li>
<li>第一个只出现一次的字符</li>
</ul>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="1-调整数组顺序使奇数位于偶数前面"><a href="#1-调整数组顺序使奇数位于偶数前面" class="headerlink" title="1. 调整数组顺序使奇数位于偶数前面"></a>1. 调整数组顺序使奇数位于偶数前面</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[left] % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nums[right] % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">const</span> temp = nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-和为-S-的两个数字"><a href="#2-和为-S-的两个数字" class="headerlink" title="2. 和为 S 的两个数字"></a>2. 和为 S 的两个数字</h4><p>输入一个递增排序的数组和一个数字 S ，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积是最小的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> sum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> [nums[left], nums[right]]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-和为-S-的连续正整数序列"><a href="#3-和为-S-的连续正整数序列" class="headerlink" title="3. 和为 S 的连续正整数序列"></a>3. 和为 S 的连续正整数序列</h4><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）</p>
<p><strong>思路</strong>：借用滑动窗口实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findContinuousSequence = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">window</span> = [];</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; target) &#123;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="built_in">window</span>.push(right);</span><br><span class="line">        sum += right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sum &gt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="built_in">window</span>.shift();</span><br><span class="line">            sum -= left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum === target &amp;&amp; <span class="built_in">window</span>.length&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            res.push(<span class="built_in">window</span>.slice());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-两数之和"><a href="#4-两数之和" class="headerlink" title="4. 两数之和"></a>4. 两数之和</h4><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code> ，请在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。</p>
<p>解析：因为数组不是有序的数组，所以不适合利用左右指针去寻找两数之和。可以使用两个 for 循环进行遍历，简单粗暴，但是时间复杂度很高。</p>
<p>所以使用一个 map 函数将遍历过的数字存储起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.has(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> [map.get(target - nums[i]), i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-三数之和"><a href="#5-三数之和" class="headerlink" title="5. 三数之和"></a>5. 三数之和</h4><p>给定一个包含 n 个整数的数组 <code>nums</code> ，判断 <code>nums</code> 中是否存在三个元素 <code>a,b,c</code> ，使得 <code>a + b + c = 0</code> 找出所有满足条件且不重复的三元组。</p>
<p><strong>思路：</strong></p>
<p>因为题目说明可能出现多组结果，有重复数字，所以要考虑好去重。</p>
<ul>
<li>为了方便去重，首先将数组进行排序</li>
<li>对数组进行遍历，取当前遍历的数 <code>nums[i]</code> 为一个基准数，遍历数后面的数组为寻找数组</li>
<li>在寻找数组中利用左右指针进行遍历</li>
<li>判断三数之和是否等于 0，如果等于 0 ，加入结果，左右指针分别进行移动一位，同时还要考虑去重。</li>
<li>结果大于 0 ，<code>right</code> 指针向左移动一位</li>
<li>结果小于 0，<code>left</code> 指针向右移动一位</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; nums[i] === nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> left = i+<span class="number">1</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">                res.push([nums[i], nums[left], nums[right]]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(nums[left] === nums[left<span class="number">-1</span>]) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(nums[right] === nums[right<span class="number">-1</span>]) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-四数之和"><a href="#6-四数之和" class="headerlink" title="6. 四数之和"></a>6. 四数之和</h4><p>给定一个包含 n 个整数的数组 <code>nums</code> ，判断 <code>nums</code> 中是否存在四个元素 <code>a, b, c, d</code> ，使得 <code>a + b + c + d = 0</code>。找出所有满足条件且不重复的四元组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fourSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt; <span class="number">4</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a-b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length<span class="number">-3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; nums[i] === nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt;nums.length<span class="number">-2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] === nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> left = j+<span class="number">1</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">const</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">                    res.push([nums[i], nums[j], nums[left], nums[right]]);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">while</span>(nums[left] === nums[left<span class="number">-1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(nums[right] === nums[right+<span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="7-构建数组乘积"><a href="#7-构建数组乘积" class="headerlink" title="7. 构建数组乘积"></a>7. 构建数组乘积</h4><p>给定一个数组 A <code>[0, 1, ..., n-1]</code>，请构建一个数组 B <code>[0, 1, ..., n-1]</code>，其中 B 中的元素 <code>B[i] = A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。</p>
<p>思路：两种方法</p>
<p><strong>方法一</strong>：可以使用两个数组，分别从前和从后开始遍历，一个保存前 i 个数的乘积，一个保存后 i 个数的乘积。然后利用这两个数组构建B</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constructArr = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(a.length);</span><br><span class="line">    <span class="keyword">const</span> pre = <span class="keyword">new</span> <span class="built_in">Array</span>(a.length);</span><br><span class="line">    <span class="keyword">const</span> last = <span class="keyword">new</span> <span class="built_in">Array</span>(a.length);</span><br><span class="line"></span><br><span class="line">    pre[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i&lt;a.length; i++) &#123;</span><br><span class="line">        pre[i] = a[i] * pre[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last[a.length<span class="number">-1</span>] = a[a.length<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=a.length<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        last[i] = a[i] * last[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b[<span class="number">0</span>] = last[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;a.length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        b[i] = pre[i<span class="number">-1</span>] * last[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    b[a.length<span class="number">-1</span>] = pre[a.length<span class="number">-2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：构建对角线元素都为 1 的二维矩阵，<code>B[i]</code> 的值相当于矩阵每行的乘积。可以将 B 数组分为上下两个三角，先计算下三角，然后将上三角乘进去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(array) &amp;&amp; array.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算下三角</span></span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">            result[i] = result[i<span class="number">-1</span>] * array[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 乘上三角</span></span><br><span class="line">        <span class="keyword">let</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            temp = temp * array[i+<span class="number">1</span>];</span><br><span class="line">            result[i] = result[i] * temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-顺时针打印数组"><a href="#8-顺时针打印数组" class="headerlink" title="8. 顺时针打印数组"></a>8. 顺时针打印数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> boundl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> boundr = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> boundt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> boundb = m<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> turn = n === <span class="number">1</span> ? <span class="string">'d'</span> : <span class="string">'r'</span>;</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> a=<span class="number">0</span>; a&lt;m*n; a++) &#123;</span><br><span class="line">        result.push(matrix[i][j]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (turn === <span class="string">'r'</span>) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (j === boundr) &#123;</span><br><span class="line">                turn = <span class="string">'d'</span>;</span><br><span class="line">                boundt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (turn === <span class="string">'d'</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i === boundb) &#123;</span><br><span class="line">                turn = <span class="string">'l'</span>;</span><br><span class="line">                boundr--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (turn === <span class="string">'l'</span>) &#123;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span> (j === boundl) &#123;</span><br><span class="line">                turn = <span class="string">'t'</span>;</span><br><span class="line">                boundb--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (turn === <span class="string">'t'</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">if</span> (i === boundt) &#123;</span><br><span class="line">                turn = <span class="string">'r'</span>;</span><br><span class="line">                boundl++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-数组中出现次数超过数组长度一半的数字"><a href="#9-数组中出现次数超过数组长度一半的数字" class="headerlink" title="9. 数组中出现次数超过数组长度一半的数字"></a>9. 数组中出现次数超过数组长度一半的数字</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">	<span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(nums.length/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.has(nums[i])) &#123;</span><br><span class="line">            map.set(nums[i], map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(nums[i]) &gt; mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="10-连续子数组的最大和"><a href="#10-连续子数组的最大和" class="headerlink" title="10. 连续子数组的最大和"></a>10. 连续子数组的最大和</h4><p>输入一个整型数组，数组里有正数也有负数。数组的一个或连续多个整数组成一个子数组。求所有子数组的最大值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> max = nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            sum = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>利用动态规划的思路解决。</p>
<ul>
<li>首先对数据进行遍历，当前最大连续子序列和为 sum，结果为 max 。</li>
<li>如果 <code>sum &gt; 0</code>，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字</li>
<li>如果 <code>sum &lt; 0</code>，则说明 sum 对结果无增益效果，需要舍弃，sum 直接更新为当前遍历数字。</li>
<li>敝教教 sum 和 max 大小，将最大值置为 max。</li>
</ul>
<h4 id="11-扑克牌顺子"><a href="#11-扑克牌顺子" class="headerlink" title="11. 扑克牌顺子"></a>11. 扑克牌顺子</h4><p>扑克牌中随机抽取 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。</p>
<p>思路：</p>
<ul>
<li>将数组进行排序</li>
<li>遍历数组，若值为 0 ，记录 0 的个数加 1 ； 若不为 0 ，记录与下一个元素的间隔</li>
<li>最后比较 0 的个数和间隔数，间隔数大于 0 的个数不能构成顺子</li>
<li>中间如果有两个元素相等则不能构成顺子。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isStraight = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> zeroCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> spaceCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] === <span class="number">0</span>) zeroCount++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> space = nums[i<span class="number">-1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (space === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                spaceCount += space<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (spaceCount - zeroCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-第一个只出现一次的字符"><a href="#12-第一个只出现一次的字符" class="headerlink" title="12. 第一个只出现一次的字符"></a>12. 第一个只出现一次的字符</h4><p>在一个字符串中找到第一个只出现一次的字符，并返回它的位置，如果没有则返回 -1 。（区分大小写）</p>
<p><strong>思路：</strong>遍历两次，第一次遍历存储元素出现的次数，第二次遍历找出第一个只出现一次的字符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> a = s[i];</span><br><span class="line">        map.has(a) ? map.set(a, map.get(a) + <span class="number">1</span>) : map.set(a, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> a = s[i];</span><br><span class="line">        <span class="keyword">if</span> (map.get(a) === <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">" "</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/数组遍历问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/数组遍历问题/" itemprop="url">数组遍历问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="岛屿面积问题"><a href="#岛屿面积问题" class="headerlink" title="岛屿面积问题"></a>岛屿面积问题</h4><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p>
<p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxAreaOfIsland = <span class="function"><span class="params">grid</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> m = grid.length;</span><br><span class="line">    <span class="keyword">const</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">i, j</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;=m || j&lt;<span class="number">0</span> || j&gt;=n || grid[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">1</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>; <span class="comment">// 遍历完之后置空</span></span><br><span class="line">        sum += dfs(i+<span class="number">1</span>, j);</span><br><span class="line">        sum += dfs(i<span class="number">-1</span>, j);</span><br><span class="line">        sum += dfs(i, j<span class="number">-1</span>);</span><br><span class="line">        sum += dfs(i, j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            max = <span class="built_in">Math</span>.max(max, dfs(i, j))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="黄金矿工"><a href="#黄金矿工" class="headerlink" title="黄金矿工"></a>黄金矿工</h4><p>不能重复走</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getMaximumGold = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> m = grid.length;</span><br><span class="line">    <span class="keyword">const</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">r, c, sum</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;=m || c&lt;<span class="number">0</span> || c&gt;=n || grid[r][c] === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> temp = grid[r][c];</span><br><span class="line">        sum += grid[r][c];</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> a = dfs(r+<span class="number">1</span>, c, sum);</span><br><span class="line">        <span class="keyword">let</span> b = dfs(r<span class="number">-1</span>, c, sum);</span><br><span class="line">        <span class="keyword">let</span> e = dfs(r, c<span class="number">-1</span>, sum);</span><br><span class="line">        <span class="keyword">let</span> f = dfs(r, c+<span class="number">1</span>, sum);</span><br><span class="line">        grid[r][c] = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(a, b, e, f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] !== <span class="number">0</span>) &#123;</span><br><span class="line">                max = <span class="built_in">Math</span>.max(max, dfs(i, j, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/十大经典排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/十大经典排序算法/" itemprop="url">十大经典排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h2><p>十种常见的排序算法可以分为两大类：</p>
<ul>
<li><strong>比较类排序：</strong>通过比较来决定元素间的相对次序。因为时间复杂度不能突破 <code>O(NlogN)</code>，所以也称为非线性时间比较类排序</li>
<li><strong>非比较类排序：</strong>不通过比较来决定元素间的相对次序，可以突破基于比较排序的时间下界，以线性时间运行，也称线性时间非比较类排序</li>
</ul>
<p><img src="C:%5CUsers%5Ccheng%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210707145714938.png" alt="image-20210707145714938"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li>稳定：如果 a 原本在 b 前面，a = b，排序之后 a 仍然在 b 的前面</li>
<li>不稳定：如果 a 原本在 b 的前面，而 a = b，排序之后 a 可能出现在 b 的后面</li>
<li>时间复杂度：对排序数据总的操作次数。反映当 n 变化时，操作次数呈现什么规律</li>
<li>空间复杂度：指算法在计算机内执行时所需存储空间的度量，也是数据规模 n 的函数</li>
</ul>
<table>
<thead>
<tr>
<th>排序方法</th>
<th align="center">时间复杂度（平均）</th>
<th align="center">时间复杂度（最坏）</th>
<th align="center">时间复杂度（最好）</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td align="center">O(n*n)</td>
<td align="center">O(n*n)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td align="center">O(n*n)</td>
<td align="center">O(n*n)</td>
<td align="center">O(n*n)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td align="center">O(n*n)</td>
<td align="center">O(n*n)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td align="center">O(n*log n)</td>
<td align="center">O(n*n)</td>
<td align="center">O(n*log n)</td>
<td align="center">O(1) / O(log n)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td align="center">O(n^1.3)</td>
<td align="center">O(n*n)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td align="center">O(n*log n)</td>
<td align="center">O(n*log n)</td>
<td align="center">O(n*log n)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td align="center">O(n*log n)</td>
<td align="center">O(n* log n)</td>
<td align="center">O(n*log n)</td>
<td align="center">O(n)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>计数排序</td>
<td align="center">O(n + k)</td>
<td align="center">O(n + k)</td>
<td align="center">O(n + k)</td>
<td align="center">O(n + k)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td align="center">O(n + k)</td>
<td align="center">O(n*n)</td>
<td align="center">O(n + k)</td>
<td align="center">O(n + k)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n + k)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p>$$</p>
<p>$$</p>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>冒泡排序重复走访过要排序的数列，一次比较两个元素，如果顺序错误就交换。每一次遍历都将固定一个值，最大或最小。这个算法名字的由来是因为越小的元素会经由交换慢慢浮到数列的顶端。</p>
<p><strong>算法描述：</strong></p>
<ul>
<li>比较相邻的元素，如果第一个比第二个大，就交换它们</li>
<li>对每一对相邻元素做同样的工作，从开始到最后，这样在最后的元素应该会是最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>重复步骤 1~3，知道排序完成</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;len-i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">                arr[i+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序的元素中寻找最小（大）元素，然后放到已排序序列的末尾。直到所有元素排序完毕。</p>
<p><strong>算法描述：</strong></p>
<p>n 个记录的直接选择排序可经过 n - 1 趟直接选择排序得到有序结果。</p>
<ul>
<li>初始状态：无序区为 R[1..n]，有序区为空；</li>
<li>第 i 趟开始时，当前有序区和无序区分别为 R[1..i-1] 和 R[i..n] 。该趟排序从当前无序区中选出关键字最小的记录 R[k] ，将其与无序区的第 1 个记录 R 交换，使 R[1..i] 和 R[i+1..n] 分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区</li>
<li>n - 1 趟结束，数组有序化了。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=i+<span class="number">1</span>; j&lt;len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析：</strong></p>
<p>表现最稳定的排序算法之一，因为无论什么数据进去都是 <code>O(n^2)</code> 的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处是不占用额外的内存空间。</p>
<h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><p>插入排序工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>
<p><strong>算法描述：</strong></p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已排序的元素序列中从后向前扫描</li>
<li>如果该元素大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤 2~5</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> preIndex = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">const</span> current = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h3><p>希尔排序和插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong></p>
<p><strong>实质上是分组插入排序</strong></p>
<p><strong>算法描述：</strong></p>
<p>先将整个待排序的记录序列分割称为若干自许雷分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列 <code>t1, t2, ..., tk</code>，其中 </li>
<li>按增量序列个数 k ，对序列进行 k 趟排序</li>
<li>每趟排序，根据对应的增量 ti，将带排序列分割成若干长度的子序列，分别对各子表进行直接插入排序</li>
</ul>
<p>比如数组 <code>[7,6,9,3,1,5,2,4]</code></p>
<p>希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序。</p>
<p>选择增量 gap = length/2，缩小增量以 gap = gap / 2 的方式</p>
<ul>
<li>第一趟排序：[1, 5, 2, 3, 7, 6, 9, 4]; gap = 4。</li>
<li>第二趟排序：[1, 3, 2, 4, 7, 5, 9, 6]; gap = 2。</li>
<li>第三趟排序：[1, 2, 3, 4, 5, 6, 7, 9]; gap = 1</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>); gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> j = i;</span><br><span class="line">            <span class="keyword">const</span> current = arr[i];</span><br><span class="line">            <span class="keyword">while</span>(j-gap &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">                j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><p>该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p>
<p><strong>算法描述：</strong></p>
<ul>
<li>把长度为 n 的输入序列分成两个长度为 n/2 的子序列</li>
<li>对这两个子序列分别采用归并排序</li>
<li>将两个排序好的子序列合并成一个最终的排序序列</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> middle = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">const</span> right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">while</span>(left.length&gt;<span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left.length) &#123;</span><br><span class="line">        result.push(left.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right.length) &#123;</span><br><span class="line">        result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析：</strong></p>
<p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 <code>O(nlogn)</code>的时间复杂度。代价是需要额外的内存空间。</p>
<h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，</p>
<p><strong>算法描述：</strong></p>
<p>从数列中挑出一个元素作为基准，重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面。在这个分区退出后，该基准就处于数列的中间位置。</p>
<p>递归地把小于基准值元素的子数列和大于基准值元素的子序列排序</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> partitionIndex;</span><br><span class="line">    <span class="keyword">const</span> left = <span class="keyword">typeof</span> left !== <span class="string">'number'</span> ? <span class="number">0</span> : left;</span><br><span class="line">    <span class="keyword">const</span> right = <span class="keyword">typeof</span> right !== <span class="string">'number'</span> ? len<span class="number">-1</span> : right;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex<span class="number">-1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left ,right</span>) </span>&#123;     <span class="comment">// 分区操作</span></span><br><span class="line">    <span class="keyword">var</span> pivot = left,                      <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><p>堆排序是指利用堆这种数据结构设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。</p>
<ul>
<li>大顶堆：每个节点的值大于或等于其左右孩子节点的值，称为大顶堆</li>
<li>小顶堆：每个节点的值小于或等于其左右孩子节点的值，称为小顶堆</li>
</ul>
<p><strong>算法描述：</strong></p>
<ul>
<li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</li>
<li>将堆顶元素与末尾元素交换，将最大元素沉到数组末端</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素</li>
<li>反复执行调整 + 交换步骤，直到整个序列有序</li>
</ul>
<h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p><strong>算法描述：</strong></p>
<ul>
<li>找出待排序的数组中最大和最小的元素</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项。</li>
<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就近将 C(i) 减去 1。</li>
</ul>
<p><strong>算法分析：</strong></p>
<p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0 到 k 之间的整数时，时间复杂度是 <code>O(n+k)</code>，空间复杂度也是 <code>O(n+k)</code>，其排序速度快于任何比较排序算法。当 k 不是很大并且序列比较集中时，计数排序时一个很有效的排序算法。</p>
<h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h3><p>桶排序是计数排序的升级版。他利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分配到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）</p>
<p><strong>算法描述：</strong></p>
<ul>
<li>设置一个定量的数组当作空桶</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去</li>
<li>对每个不是空的桶进行排序</li>
<li>从不是空的桶里把排好序的数据拼接起来</li>
</ul>
<p><strong>算法分析：</strong></p>
<p>桶排序最好情况下使用线性时间 <code>O(n)</code>，桶排序的时间复杂度，取决于各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 <code>O(n)</code>。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
<h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p><strong>算法描述：</strong></p>
<ul>
<li>取得数组中的最大数，并取得位数</li>
<li>arr 为原始数组，从最低位开始取每个位组成 radix 数组</li>
<li>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）</li>
</ul>
<p><strong>算法分析：</strong></p>
<p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的同分配都需要 <code>O(n)</code> 的时间复杂度，而且分配之后得到新的关键字序列又需要 <code>O(n)</code> 的时间复杂度。假如待排数据可以分为 d 个关键字，则基数排序的时间复杂度将是 <code>O(d*2n)</code>，当然 d 要远远小于 n，因此基本还是线性级别的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/链表概览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/链表概览/" itemprop="url">链表概览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="链表系列"><a href="#链表系列" class="headerlink" title="链表系列"></a>链表系列</h2><p>用一组任意存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。</p>
<ul>
<li>需要遍历才能查询到元素，查询慢</li>
<li>插入元素只需要断开连接重新赋值，插入快</li>
</ul>
<h3 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h3><p>主要是对链表基本概念和特性的应用，如果基础概念掌握牢靠，此类问题即可解决。</p>
<ul>
<li>从尾到头打印链表</li>
<li>删除链表中的节点</li>
<li>反转链表</li>
<li>复杂链表的复制</li>
</ul>
<h3 id="环类题目"><a href="#环类题目" class="headerlink" title="环类题目"></a>环类题目</h3><p>环类链表即从判断一个单链表是否存在循环而扩展衍生的问题</p>
<ul>
<li>环形链表</li>
<li>链表环的入口节点</li>
<li>约瑟夫环</li>
</ul>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>双指针的思想在链表和数组中的题目都会经常用到，主要是利用两个或多个不同位置的指针，通过速度和方向的变换解决问题。比如快慢指针和左右指针。</p>
<ul>
<li>左右指针：两个指针从不同位置出发，一个从始端开始，一个从末端开始</li>
<li>快慢指针：两个指针以不同速度移动，一个指针快一些，一个指针慢一些。</li>
</ul>
<p>对于单链表，因为只能在一个方向上遍历链表，所以左右指针很难实施，但快慢指针是非常适用的。</p>
<ul>
<li>两个链表的公共节点</li>
<li>链表的倒数第 k 个节点</li>
<li>相交链表</li>
</ul>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双链还有一个引用字段，称为 <code>prev</code> 字段，有了这个额外的字段，就可以知道当前节点的前一个结点</p>
<ul>
<li>扁平化多级双向链表</li>
</ul>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="1-从尾到头打印链表"><a href="#1-从尾到头打印链表" class="headerlink" title="1. 从尾到头打印链表"></a>1. 从尾到头打印链表</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printListFromTailToHead</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [];</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">        arr.unshift(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-删除链表中的结点"><a href="#2-删除链表中的结点" class="headerlink" title="2. 删除链表中的结点"></a>2. 删除链表中的结点</h4><ul>
<li>删除的结点不是尾部结点：next 结点覆盖当前结点</li>
<li>删除的结点是尾部结点且等于头结点，只剩一个结点：将头结点置为 <code>null</code></li>
<li>删除的结点是尾结点且前面还有结点：遍历到末尾的前一个结点删除</li>
</ul>
<p>只有第三种情况的时间复杂度是 <code>O(n)</code>，且这种情况只会出现 <code>1/n</code> 次，所以算法的时间复杂度是 <code>O(1)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.val == val) <span class="keyword">return</span> head.next;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur.next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.next.val == val) &#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>删除表中重复的结点</strong></p>
<p>可以存储链表中元素出现的次数，用一个 map 存储每个结点出现的次数，删除出现次数大于 1 的结点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteDuplication</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    map.set(cur.val, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(cur.next) &#123;</span><br><span class="line">        map.set(cur.next.val, map.has(cur.next.val) ? map.get(cur.next.val) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (map.get(cur.next.val) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-反转链表"><a href="#3-反转链表" class="headerlink" title="3. 反转链表"></a>3. 反转链表</h4><p>输入一个链表，反转链表后，输出新链表的表头</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="keyword">const</span> next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="params">head</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">const</span> last = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-复杂链表的复制"><a href="#4-复杂链表的复制" class="headerlink" title="4. 复杂链表的复制"></a>4. 复杂链表的复制</h4><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。</p>
<h4 id="5-环形链表"><a href="#5-环形链表" class="headerlink" title="5. 环形链表"></a>5. 环形链表</h4><p>给定一个链表，判断链表中是否有环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast,slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-环形链表入口节点"><a href="#6-环形链表入口节点" class="headerlink" title="6. 环形链表入口节点"></a>6. 环形链表入口节点</h4><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!fast || !fast.next) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-约瑟夫环"><a href="#7-约瑟夫环" class="headerlink" title="7. 约瑟夫环"></a>7. 约瑟夫环</h4><p><code>0,1,...,n-1</code> 这 n 个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第 m 个数字。求出这个圆圈里剩下的最后一个数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LastRemaining_Solution</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">1</span> || m&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先用链表模拟环</span></span><br><span class="line">    <span class="keyword">const</span> head = &#123; <span class="attr">val</span>:<span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> current = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        curren.next = &#123;<span class="attr">val</span> : i&#125;;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current.next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(current.next != current) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;m<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = current.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-两个链表的第一个公共节点"><a href="#8-两个链表的第一个公共节点" class="headerlink" title="8. 两个链表的第一个公共节点"></a>8. 两个链表的第一个公共节点</h4><p>输入两个链表，找出它们的第一个公共节点</p>
<ul>
<li>先找到两个链表的长度</li>
<li>让长一点的链表先走，让长链表和短链表起点相同</li>
<li>两个链表一起前进，比较获得第一个相等的节点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindFirstCommonNode</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取链表长度</span></span><br><span class="line">    <span class="keyword">let</span> lengthA = getLength(headA);</span><br><span class="line">    <span class="keyword">let</span> lengthB = getLength(headB);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lengthA &gt; lengthB) &#123;</span><br><span class="line">        <span class="keyword">let</span> interver = lengthA - lengthB;</span><br><span class="line">        <span class="keyword">while</span>(interver) &#123;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">            interver--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> interver = lengthB - lengthA;</span><br><span class="line">        <span class="keyword">while</span>(interver) &#123;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">            interver--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(headA) &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == headB) &#123;</span><br><span class="line">            <span class="keyword">return</span> headA;</span><br><span class="line">        &#125;</span><br><span class="line">        headA = headA.next;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> current = head;</span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-链表的倒数第-k-个节点"><a href="#9-链表的倒数第-k-个节点" class="headerlink" title="9. 链表的倒数第 k 个节点"></a>9. 链表的倒数第 k 个节点</h4><p>输入一个链表，输出链表中倒数第 k 个节点。</p>
<p>使用快慢指针，让快指针先走 k 步，然后同速前进，快指针到达终点时慢指针指向倒数第 k 个节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findKthToTail</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast,slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果此时走到头了，则说明倒数第 k 个节点就是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (!fast) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="连续数组"><a href="#连续数组" class="headerlink" title="连续数组"></a>连续数组</h4><p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaxLength = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">    map.set(counter, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> num = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.has(counter)) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevIndex = map.get(counter);</span><br><span class="line">            maxLength = <span class="built_in">Math</span>.max(maxLength, i - prevIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(counter, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/05/算法/解决 nSum 问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朱程程">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/first.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二、上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/算法/解决 nSum 问题/" itemprop="url">解决nSum问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-05T22:23:39+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="解决-nSum-问题"><a href="#解决-nSum-问题" class="headerlink" title="解决 nSum 问题"></a>解决 <code>nSum</code> 问题</h2><h3 id="twoSum问题"><a href="#twoSum问题" class="headerlink" title="twoSum问题"></a><code>twoSum</code>问题</h3><p>leetcode 上经典的问题，假设输入一个数组 <code>nums</code> 和一个目标 <code>target</code>，要求返回能凑出目标值的索引。</p>
<p>如果不要求返回索引而是返回凑出 <code>target</code> 的两个元素的值，那我们可以先将数组进行排序，然后利用左右指针的方法进行寻找即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a - b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">const</span> sum = nums[left] + nums[right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> [nums[left], nums[right]];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能够解决问题，但是这题目是假设 <code>nums</code> 中有且只有一个答案，但如果修改这个条件：<code>nums</code> 中可能有多对元素之和都等于 <code>target</code> 。要求返回所有和为 <code>target</code> 的元素对，其中不能出现重复。</p>
<p>这里要注意，<strong>要求去掉重复，所以在判断相等之后，还要注意进行去重</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> sum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">            result.push([nums[left], nums[right]]);</span><br><span class="line">            <span class="keyword">while</span>(nums[left+<span class="number">1</span>] == nums[left]) &#123;</span><br><span class="line">                left++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(nums[right<span class="number">-1</span>] == nums[right]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一个通用的 <code>twoSum</code> 函数就写出来了，后面的 <code>threeSum</code> 和 <code>fourSum</code> 都会复用这个函数。</p>
<h3 id="二、3Sum-问题"><a href="#二、3Sum-问题" class="headerlink" title="二、3Sum 问题"></a>二、3Sum 问题</h3><p>判断数组 <code>nums</code> 中是否存在三个元素使得 <code>a + b + c = target</code> ，找出所有满足条件且不重复的三元组.</p>
<p>思路：想找和为 <code>target</code> 的三个数字，对于第一个数字，<code>nums</code> 中每一个元素 <code>nums[i]</code> 都有可能。确定了第一个数字后，剩下的两个数就是和为 <code>target - nums[i]</code> 的两个数，即 <code>twoSum</code> 函数的解决方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, start, target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 左指针改为 start 开始，其它不变</span></span><br><span class="line">    <span class="keyword">let</span> left = start, right = nums.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> two = twoSum(nums, i+<span class="number">1</span>, target-nums[i]);</span><br><span class="line">        <span class="keyword">for</span> (item <span class="keyword">of</span> two) &#123;</span><br><span class="line">            item.push(nums[i]);</span><br><span class="line">            res.push(item.slice());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳过数字重复的情况</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n<span class="number">-1</span> &amp;&amp; nums[i] === nums[i+<span class="number">1</span>]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似 <code>twoSum</code> ，<code>threeSum</code> 的结果也可能重复。<strong>关键点在于不能使第一个数重复，至于后面两个数，复用的 <code>twoSum</code> 函数会保证它们不重复</strong>。</p>
<p>至此，<code>threeSum</code> 问题就解决了。</p>
<h3 id="三、fourSum-问题"><a href="#三、fourSum-问题" class="headerlink" title="三、fourSum 问题"></a>三、fourSum 问题</h3><p><code>fourSum</code> 问题完全可以用相同的思路：穷举第一个数字，然后调用 <code>threeSum</code> 函数计算剩下的三个数，最后组合出和为 <code>target</code> 的四元组。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/first.jpg" alt="朱程程">
            
              <p class="site-author-name" itemprop="name">朱程程</p>
              <p class="site-description motion-element" itemprop="description">人生当苦无妨，良人当归即好</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/devil-chengcheng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱程程</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
